# All code here


# DAPAtlasMetadata.ipynb

{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6ba3aa36",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "import os\n",
    "import torch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ddf218ca",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the path to your metadata CSV file\n",
    "metadata_file = '../utils/Clinical Metadata FDG PET_CT Lesions.csv'  # replace with the actual path to your CSV file\n",
    "output_directory = '../outputs/plotsDAPAtlas'  # Directory to save plots\n",
    "\n",
    "# Ensure the output directory exists\n",
    "os.makedirs(output_directory, exist_ok=True)\n",
    "\n",
    "# Try reading the CSV file with better error handling\n",
    "original = pd.read_csv(metadata_file)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "21e5ed13",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Series UID</th>\n",
       "      <th>Collection</th>\n",
       "      <th>3rd Party Analysis</th>\n",
       "      <th>Data Description URI</th>\n",
       "      <th>Subject ID</th>\n",
       "      <th>Study UID</th>\n",
       "      <th>Study Description</th>\n",
       "      <th>Study Date</th>\n",
       "      <th>Series Description</th>\n",
       "      <th>Manufacturer</th>\n",
       "      <th>Modality</th>\n",
       "      <th>SOP Class Name</th>\n",
       "      <th>SOP Class UID</th>\n",
       "      <th>Number of Images</th>\n",
       "      <th>File Size</th>\n",
       "      <th>File Location</th>\n",
       "      <th>Download Timestamp</th>\n",
       "      <th>diagnosis</th>\n",
       "      <th>age</th>\n",
       "      <th>sex</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.201203836389...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0011f3deaf</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>3/23/2003</td>\n",
       "      <td>Segmentation</td>\n",
       "      <td>QIICR</td>\n",
       "      <td>SEG</td>\n",
       "      <td>Segmentation Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.66.4</td>\n",
       "      <td>1</td>\n",
       "      <td>6.75 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...</td>\n",
       "      <td>2022-03-17T12:53:16.75</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>063Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.685145825998...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0011f3deaf</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>3/23/2003</td>\n",
       "      <td>PET corr.</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>PT</td>\n",
       "      <td>Positron Emission Tomography Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.128</td>\n",
       "      <td>326</td>\n",
       "      <td>105.82 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...</td>\n",
       "      <td>2022-03-17T12:53:44.865</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>063Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.151532511484...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_01140d52d8</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.316964892168...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>8/13/2005</td>\n",
       "      <td>PET corr.</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>PT</td>\n",
       "      <td>Positron Emission Tomography Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.128</td>\n",
       "      <td>305</td>\n",
       "      <td>99.01 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_01140d52d8/08-13-20...</td>\n",
       "      <td>2022-03-17T12:53:45.761</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>061Y</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.313152023416...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_01140d52d8</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.316964892168...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>8/13/2005</td>\n",
       "      <td>Segmentation</td>\n",
       "      <td>QIICR</td>\n",
       "      <td>SEG</td>\n",
       "      <td>Segmentation Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.66.4</td>\n",
       "      <td>1</td>\n",
       "      <td>6.31 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_01140d52d8/08-13-20...</td>\n",
       "      <td>2022-03-17T12:53:47.839</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>061Y</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.331726561677...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0011f3deaf</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>3/23/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>391</td>\n",
       "      <td>206.52 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...</td>\n",
       "      <td>2022-03-17T12:53:53.415</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>063Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3037</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.268371672619...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_ff1451316e</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.172967091722...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>3/31/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>391</td>\n",
       "      <td>206.53 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_ff1451316e/03-31-20...</td>\n",
       "      <td>2022-03-17T21:50:46.509</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>073Y</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3038</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.236102552014...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_fe705ea1cc</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.319090403244...</td>\n",
       "      <td>Unspecified CT ABDOMEN</td>\n",
       "      <td>12/29/2002</td>\n",
       "      <td>GK p.v.1 WF</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>1214</td>\n",
       "      <td>641.06 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_fe705ea1cc/12-29-20...</td>\n",
       "      <td>2022-03-17T21:51:00.132</td>\n",
       "      <td>LYMPHOMA</td>\n",
       "      <td>066Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3039</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.330497593503...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_ff39795341</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.253687934564...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>9/22/2005</td>\n",
       "      <td>Segmentation</td>\n",
       "      <td>QIICR</td>\n",
       "      <td>SEG</td>\n",
       "      <td>Segmentation Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.66.4</td>\n",
       "      <td>1</td>\n",
       "      <td>11.13 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_ff39795341/09-22-20...</td>\n",
       "      <td>2022-03-17T21:51:04.996</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>073Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3040</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.117635362952...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_ff39795341</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.253687934564...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>9/22/2005</td>\n",
       "      <td>GK p.v.3 s</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>645</td>\n",
       "      <td>340.68 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_ff39795341/09-22-20...</td>\n",
       "      <td>2022-03-17T21:51:26.506</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>073Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3041</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.168850580521...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_ff39795341</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.253687934564...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>9/22/2005</td>\n",
       "      <td>PET corr.</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>PT</td>\n",
       "      <td>Positron Emission Tomography Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.128</td>\n",
       "      <td>538</td>\n",
       "      <td>174.65 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_ff39795341/09-22-20...</td>\n",
       "      <td>2022-03-17T21:51:34.946</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>073Y</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>3042 rows × 20 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "                                             Series UID          Collection  \\\n",
       "0     1.3.6.1.4.1.14519.5.2.1.4219.6651.201203836389...  FDG-PET-CT-Lesions   \n",
       "1     1.3.6.1.4.1.14519.5.2.1.4219.6651.685145825998...  FDG-PET-CT-Lesions   \n",
       "2     1.3.6.1.4.1.14519.5.2.1.4219.6651.151532511484...  FDG-PET-CT-Lesions   \n",
       "3     1.3.6.1.4.1.14519.5.2.1.4219.6651.313152023416...  FDG-PET-CT-Lesions   \n",
       "4     1.3.6.1.4.1.14519.5.2.1.4219.6651.331726561677...  FDG-PET-CT-Lesions   \n",
       "...                                                 ...                 ...   \n",
       "3037  1.3.6.1.4.1.14519.5.2.1.4219.6651.268371672619...  FDG-PET-CT-Lesions   \n",
       "3038  1.3.6.1.4.1.14519.5.2.1.4219.6651.236102552014...  FDG-PET-CT-Lesions   \n",
       "3039  1.3.6.1.4.1.14519.5.2.1.4219.6651.330497593503...  FDG-PET-CT-Lesions   \n",
       "3040  1.3.6.1.4.1.14519.5.2.1.4219.6651.117635362952...  FDG-PET-CT-Lesions   \n",
       "3041  1.3.6.1.4.1.14519.5.2.1.4219.6651.168850580521...  FDG-PET-CT-Lesions   \n",
       "\n",
       "     3rd Party Analysis  Data Description URI        Subject ID  \\\n",
       "0                    NO                   NaN  PETCT_0011f3deaf   \n",
       "1                    NO                   NaN  PETCT_0011f3deaf   \n",
       "2                    NO                   NaN  PETCT_01140d52d8   \n",
       "3                    NO                   NaN  PETCT_01140d52d8   \n",
       "4                    NO                   NaN  PETCT_0011f3deaf   \n",
       "...                 ...                   ...               ...   \n",
       "3037                 NO                   NaN  PETCT_ff1451316e   \n",
       "3038                 NO                   NaN  PETCT_fe705ea1cc   \n",
       "3039                 NO                   NaN  PETCT_ff39795341   \n",
       "3040                 NO                   NaN  PETCT_ff39795341   \n",
       "3041                 NO                   NaN  PETCT_ff39795341   \n",
       "\n",
       "                                              Study UID  \\\n",
       "0     1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...   \n",
       "1     1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...   \n",
       "2     1.3.6.1.4.1.14519.5.2.1.4219.6651.316964892168...   \n",
       "3     1.3.6.1.4.1.14519.5.2.1.4219.6651.316964892168...   \n",
       "4     1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...   \n",
       "...                                                 ...   \n",
       "3037  1.3.6.1.4.1.14519.5.2.1.4219.6651.172967091722...   \n",
       "3038  1.3.6.1.4.1.14519.5.2.1.4219.6651.319090403244...   \n",
       "3039  1.3.6.1.4.1.14519.5.2.1.4219.6651.253687934564...   \n",
       "3040  1.3.6.1.4.1.14519.5.2.1.4219.6651.253687934564...   \n",
       "3041  1.3.6.1.4.1.14519.5.2.1.4219.6651.253687934564...   \n",
       "\n",
       "                       Study Description  Study Date Series Description  \\\n",
       "0     PET-CT Ganzkoerper  primaer mit KM   3/23/2003       Segmentation   \n",
       "1     PET-CT Ganzkoerper  primaer mit KM   3/23/2003          PET corr.   \n",
       "2     PET-CT Ganzkoerper  primaer mit KM   8/13/2005          PET corr.   \n",
       "3     PET-CT Ganzkoerper  primaer mit KM   8/13/2005       Segmentation   \n",
       "4     PET-CT Ganzkoerper  primaer mit KM   3/23/2003           GK p.v.3   \n",
       "...                                  ...         ...                ...   \n",
       "3037  PET-CT Ganzkoerper  primaer mit KM   3/31/2003           GK p.v.3   \n",
       "3038              Unspecified CT ABDOMEN  12/29/2002        GK p.v.1 WF   \n",
       "3039  PET-CT Ganzkoerper  primaer mit KM   9/22/2005       Segmentation   \n",
       "3040  PET-CT Ganzkoerper  primaer mit KM   9/22/2005         GK p.v.3 s   \n",
       "3041  PET-CT Ganzkoerper  primaer mit KM   9/22/2005          PET corr.   \n",
       "\n",
       "     Manufacturer Modality                              SOP Class Name  \\\n",
       "0           QIICR      SEG                        Segmentation Storage   \n",
       "1         SIEMENS       PT  Positron Emission Tomography Image Storage   \n",
       "2         SIEMENS       PT  Positron Emission Tomography Image Storage   \n",
       "3           QIICR      SEG                        Segmentation Storage   \n",
       "4         SIEMENS       CT                            CT Image Storage   \n",
       "...           ...      ...                                         ...   \n",
       "3037      SIEMENS       CT                            CT Image Storage   \n",
       "3038      SIEMENS       CT                            CT Image Storage   \n",
       "3039        QIICR      SEG                        Segmentation Storage   \n",
       "3040      SIEMENS       CT                            CT Image Storage   \n",
       "3041      SIEMENS       PT  Positron Emission Tomography Image Storage   \n",
       "\n",
       "                     SOP Class UID  Number of Images  File Size  \\\n",
       "0     1.2.840.10008.5.1.4.1.1.66.4                 1    6.75 MB   \n",
       "1      1.2.840.10008.5.1.4.1.1.128               326  105.82 MB   \n",
       "2      1.2.840.10008.5.1.4.1.1.128               305   99.01 MB   \n",
       "3     1.2.840.10008.5.1.4.1.1.66.4                 1    6.31 MB   \n",
       "4        1.2.840.10008.5.1.4.1.1.2               391  206.52 MB   \n",
       "...                            ...               ...        ...   \n",
       "3037     1.2.840.10008.5.1.4.1.1.2               391  206.53 MB   \n",
       "3038     1.2.840.10008.5.1.4.1.1.2              1214  641.06 MB   \n",
       "3039  1.2.840.10008.5.1.4.1.1.66.4                 1   11.13 MB   \n",
       "3040     1.2.840.10008.5.1.4.1.1.2               645  340.68 MB   \n",
       "3041   1.2.840.10008.5.1.4.1.1.128               538  174.65 MB   \n",
       "\n",
       "                                          File Location  \\\n",
       "0     ./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...   \n",
       "1     ./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...   \n",
       "2     ./FDG-PET-CT-Lesions/PETCT_01140d52d8/08-13-20...   \n",
       "3     ./FDG-PET-CT-Lesions/PETCT_01140d52d8/08-13-20...   \n",
       "4     ./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...   \n",
       "...                                                 ...   \n",
       "3037  ./FDG-PET-CT-Lesions/PETCT_ff1451316e/03-31-20...   \n",
       "3038  ./FDG-PET-CT-Lesions/PETCT_fe705ea1cc/12-29-20...   \n",
       "3039  ./FDG-PET-CT-Lesions/PETCT_ff39795341/09-22-20...   \n",
       "3040  ./FDG-PET-CT-Lesions/PETCT_ff39795341/09-22-20...   \n",
       "3041  ./FDG-PET-CT-Lesions/PETCT_ff39795341/09-22-20...   \n",
       "\n",
       "           Download Timestamp diagnosis   age sex  \n",
       "0      2022-03-17T12:53:16.75  MELANOMA  063Y   F  \n",
       "1     2022-03-17T12:53:44.865  MELANOMA  063Y   F  \n",
       "2     2022-03-17T12:53:45.761  MELANOMA  061Y   M  \n",
       "3     2022-03-17T12:53:47.839  MELANOMA  061Y   M  \n",
       "4     2022-03-17T12:53:53.415  MELANOMA  063Y   F  \n",
       "...                       ...       ...   ...  ..  \n",
       "3037  2022-03-17T21:50:46.509  NEGATIVE  073Y   M  \n",
       "3038  2022-03-17T21:51:00.132  LYMPHOMA  066Y   F  \n",
       "3039  2022-03-17T21:51:04.996  NEGATIVE  073Y   F  \n",
       "3040  2022-03-17T21:51:26.506  NEGATIVE  073Y   F  \n",
       "3041  2022-03-17T21:51:34.946  NEGATIVE  073Y   F  \n",
       "\n",
       "[3042 rows x 20 columns]"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "original"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "7332ed2a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "533\n"
     ]
    }
   ],
   "source": [
    "def get_AutoPetName(item):\n",
    "    termination=item[item.rfind('/')-5:item.rfind('/')]\n",
    "    item=item[item.find('Lesions/PETCT_')+len('Lesions/PETCT_'):]\n",
    "    item=item[:item.find('/')]\n",
    "    item=item+'_'+termination\n",
    "    return 'AutoPET_'+item\n",
    "metaItens=[]\n",
    "for i,name in enumerate(original['File Location'],0):\n",
    "    if original['Modality'][i]=='CT':\n",
    "        pet=get_AutoPetName(original['File Location'][i])\n",
    "        if pet in torch.load('../utils/DAPAtlasSamples.pt'):\n",
    "            metaItens.append(pet)\n",
    "print(len(metaItens))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "051904ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.DataFrame(columns=original.columns)\n",
    "for index, row in original.iterrows():\n",
    "    if row['Modality']=='CT' and get_AutoPetName(row['File Location']) in torch.load('../utils/DAPAtlasSamples.pt'):\n",
    "        if row['age'][-1]=='Y':\n",
    "            row['age']=int(row['age'][:-1])\n",
    "        df = df.append(row, ignore_index=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "f14233b8",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Series UID</th>\n",
       "      <th>Collection</th>\n",
       "      <th>3rd Party Analysis</th>\n",
       "      <th>Data Description URI</th>\n",
       "      <th>Subject ID</th>\n",
       "      <th>Study UID</th>\n",
       "      <th>Study Description</th>\n",
       "      <th>Study Date</th>\n",
       "      <th>Series Description</th>\n",
       "      <th>Manufacturer</th>\n",
       "      <th>Modality</th>\n",
       "      <th>SOP Class Name</th>\n",
       "      <th>SOP Class UID</th>\n",
       "      <th>Number of Images</th>\n",
       "      <th>File Size</th>\n",
       "      <th>File Location</th>\n",
       "      <th>Download Timestamp</th>\n",
       "      <th>diagnosis</th>\n",
       "      <th>age</th>\n",
       "      <th>sex</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.331726561677...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0011f3deaf</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>3/23/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>391</td>\n",
       "      <td>206.52 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...</td>\n",
       "      <td>2022-03-17T12:53:53.415</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>63</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.340214977928...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_01140d52d8</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.316964892168...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>8/13/2005</td>\n",
       "      <td>GK p.v.3 s</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>366</td>\n",
       "      <td>193.37 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_01140d52d8/08-13-20...</td>\n",
       "      <td>2022-03-17T12:54:18.995</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>61</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.139507561280...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0143bab87a</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.335264930457...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>7/17/2005</td>\n",
       "      <td>GK p.v.3 s</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>345</td>\n",
       "      <td>182.27 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0143bab87a/07-17-20...</td>\n",
       "      <td>2022-03-17T12:54:47.556</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>84</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.913380603297...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0168f65af8</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.304086288813...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>4/4/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>391</td>\n",
       "      <td>206.52 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0168f65af8/04-04-20...</td>\n",
       "      <td>2022-03-17T12:55:51.533</td>\n",
       "      <td>LUNG_CANCER</td>\n",
       "      <td>73</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.125265645176...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_0410759456</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.215436249461...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>11/7/2002</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>340</td>\n",
       "      <td>179.58 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_0410759456/11-07-20...</td>\n",
       "      <td>2022-03-17T12:58:15.895</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>78</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>528</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.192944502182...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_fb014a1ea0</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.234502808892...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>12/1/2005</td>\n",
       "      <td>GK p.v.3 s</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>360</td>\n",
       "      <td>190.16 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_fb014a1ea0/12-01-20...</td>\n",
       "      <td>2022-03-17T21:44:46.9</td>\n",
       "      <td>LYMPHOMA</td>\n",
       "      <td>57</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>529</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.303584820397...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_fbd907a179</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.114084559043...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>10/4/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>340</td>\n",
       "      <td>179.58 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_fbd907a179/10-04-20...</td>\n",
       "      <td>2022-03-17T21:45:21.106</td>\n",
       "      <td>LYMPHOMA</td>\n",
       "      <td>49</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>530</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.184001889332...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_fde66dd53a</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.194294292917...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>12/22/2005</td>\n",
       "      <td>GK p.v.3 s</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>358</td>\n",
       "      <td>189.10 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_fde66dd53a/12-22-20...</td>\n",
       "      <td>2022-03-17T21:46:58.057</td>\n",
       "      <td>MELANOMA</td>\n",
       "      <td>78</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>531</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.851230154647...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_fe705ea1cc</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.972577895642...</td>\n",
       "      <td>Unspecified CT ABDOMEN</td>\n",
       "      <td>4/27/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>340</td>\n",
       "      <td>179.54 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_fe705ea1cc/04-27-20...</td>\n",
       "      <td>2022-03-17T21:50:00.466</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>66</td>\n",
       "      <td>F</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>532</th>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.268371672619...</td>\n",
       "      <td>FDG-PET-CT-Lesions</td>\n",
       "      <td>NO</td>\n",
       "      <td>NaN</td>\n",
       "      <td>PETCT_ff1451316e</td>\n",
       "      <td>1.3.6.1.4.1.14519.5.2.1.4219.6651.172967091722...</td>\n",
       "      <td>PET-CT Ganzkoerper  primaer mit KM</td>\n",
       "      <td>3/31/2003</td>\n",
       "      <td>GK p.v.3</td>\n",
       "      <td>SIEMENS</td>\n",
       "      <td>CT</td>\n",
       "      <td>CT Image Storage</td>\n",
       "      <td>1.2.840.10008.5.1.4.1.1.2</td>\n",
       "      <td>391</td>\n",
       "      <td>206.53 MB</td>\n",
       "      <td>./FDG-PET-CT-Lesions/PETCT_ff1451316e/03-31-20...</td>\n",
       "      <td>2022-03-17T21:50:46.509</td>\n",
       "      <td>NEGATIVE</td>\n",
       "      <td>73</td>\n",
       "      <td>M</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>533 rows × 20 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "                                            Series UID          Collection  \\\n",
       "0    1.3.6.1.4.1.14519.5.2.1.4219.6651.331726561677...  FDG-PET-CT-Lesions   \n",
       "1    1.3.6.1.4.1.14519.5.2.1.4219.6651.340214977928...  FDG-PET-CT-Lesions   \n",
       "2    1.3.6.1.4.1.14519.5.2.1.4219.6651.139507561280...  FDG-PET-CT-Lesions   \n",
       "3    1.3.6.1.4.1.14519.5.2.1.4219.6651.913380603297...  FDG-PET-CT-Lesions   \n",
       "4    1.3.6.1.4.1.14519.5.2.1.4219.6651.125265645176...  FDG-PET-CT-Lesions   \n",
       "..                                                 ...                 ...   \n",
       "528  1.3.6.1.4.1.14519.5.2.1.4219.6651.192944502182...  FDG-PET-CT-Lesions   \n",
       "529  1.3.6.1.4.1.14519.5.2.1.4219.6651.303584820397...  FDG-PET-CT-Lesions   \n",
       "530  1.3.6.1.4.1.14519.5.2.1.4219.6651.184001889332...  FDG-PET-CT-Lesions   \n",
       "531  1.3.6.1.4.1.14519.5.2.1.4219.6651.851230154647...  FDG-PET-CT-Lesions   \n",
       "532  1.3.6.1.4.1.14519.5.2.1.4219.6651.268371672619...  FDG-PET-CT-Lesions   \n",
       "\n",
       "    3rd Party Analysis Data Description URI        Subject ID  \\\n",
       "0                   NO                  NaN  PETCT_0011f3deaf   \n",
       "1                   NO                  NaN  PETCT_01140d52d8   \n",
       "2                   NO                  NaN  PETCT_0143bab87a   \n",
       "3                   NO                  NaN  PETCT_0168f65af8   \n",
       "4                   NO                  NaN  PETCT_0410759456   \n",
       "..                 ...                  ...               ...   \n",
       "528                 NO                  NaN  PETCT_fb014a1ea0   \n",
       "529                 NO                  NaN  PETCT_fbd907a179   \n",
       "530                 NO                  NaN  PETCT_fde66dd53a   \n",
       "531                 NO                  NaN  PETCT_fe705ea1cc   \n",
       "532                 NO                  NaN  PETCT_ff1451316e   \n",
       "\n",
       "                                             Study UID  \\\n",
       "0    1.3.6.1.4.1.14519.5.2.1.4219.6651.389860614478...   \n",
       "1    1.3.6.1.4.1.14519.5.2.1.4219.6651.316964892168...   \n",
       "2    1.3.6.1.4.1.14519.5.2.1.4219.6651.335264930457...   \n",
       "3    1.3.6.1.4.1.14519.5.2.1.4219.6651.304086288813...   \n",
       "4    1.3.6.1.4.1.14519.5.2.1.4219.6651.215436249461...   \n",
       "..                                                 ...   \n",
       "528  1.3.6.1.4.1.14519.5.2.1.4219.6651.234502808892...   \n",
       "529  1.3.6.1.4.1.14519.5.2.1.4219.6651.114084559043...   \n",
       "530  1.3.6.1.4.1.14519.5.2.1.4219.6651.194294292917...   \n",
       "531  1.3.6.1.4.1.14519.5.2.1.4219.6651.972577895642...   \n",
       "532  1.3.6.1.4.1.14519.5.2.1.4219.6651.172967091722...   \n",
       "\n",
       "                      Study Description  Study Date Series Description  \\\n",
       "0    PET-CT Ganzkoerper  primaer mit KM   3/23/2003           GK p.v.3   \n",
       "1    PET-CT Ganzkoerper  primaer mit KM   8/13/2005         GK p.v.3 s   \n",
       "2    PET-CT Ganzkoerper  primaer mit KM   7/17/2005         GK p.v.3 s   \n",
       "3    PET-CT Ganzkoerper  primaer mit KM    4/4/2003           GK p.v.3   \n",
       "4    PET-CT Ganzkoerper  primaer mit KM   11/7/2002           GK p.v.3   \n",
       "..                                  ...         ...                ...   \n",
       "528  PET-CT Ganzkoerper  primaer mit KM   12/1/2005         GK p.v.3 s   \n",
       "529  PET-CT Ganzkoerper  primaer mit KM   10/4/2003           GK p.v.3   \n",
       "530  PET-CT Ganzkoerper  primaer mit KM  12/22/2005         GK p.v.3 s   \n",
       "531              Unspecified CT ABDOMEN   4/27/2003           GK p.v.3   \n",
       "532  PET-CT Ganzkoerper  primaer mit KM   3/31/2003           GK p.v.3   \n",
       "\n",
       "    Manufacturer Modality    SOP Class Name              SOP Class UID  \\\n",
       "0        SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "1        SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "2        SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "3        SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "4        SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "..           ...      ...               ...                        ...   \n",
       "528      SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "529      SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "530      SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "531      SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "532      SIEMENS       CT  CT Image Storage  1.2.840.10008.5.1.4.1.1.2   \n",
       "\n",
       "    Number of Images  File Size  \\\n",
       "0                391  206.52 MB   \n",
       "1                366  193.37 MB   \n",
       "2                345  182.27 MB   \n",
       "3                391  206.52 MB   \n",
       "4                340  179.58 MB   \n",
       "..               ...        ...   \n",
       "528              360  190.16 MB   \n",
       "529              340  179.58 MB   \n",
       "530              358  189.10 MB   \n",
       "531              340  179.54 MB   \n",
       "532              391  206.53 MB   \n",
       "\n",
       "                                         File Location  \\\n",
       "0    ./FDG-PET-CT-Lesions/PETCT_0011f3deaf/03-23-20...   \n",
       "1    ./FDG-PET-CT-Lesions/PETCT_01140d52d8/08-13-20...   \n",
       "2    ./FDG-PET-CT-Lesions/PETCT_0143bab87a/07-17-20...   \n",
       "3    ./FDG-PET-CT-Lesions/PETCT_0168f65af8/04-04-20...   \n",
       "4    ./FDG-PET-CT-Lesions/PETCT_0410759456/11-07-20...   \n",
       "..                                                 ...   \n",
       "528  ./FDG-PET-CT-Lesions/PETCT_fb014a1ea0/12-01-20...   \n",
       "529  ./FDG-PET-CT-Lesions/PETCT_fbd907a179/10-04-20...   \n",
       "530  ./FDG-PET-CT-Lesions/PETCT_fde66dd53a/12-22-20...   \n",
       "531  ./FDG-PET-CT-Lesions/PETCT_fe705ea1cc/04-27-20...   \n",
       "532  ./FDG-PET-CT-Lesions/PETCT_ff1451316e/03-31-20...   \n",
       "\n",
       "          Download Timestamp    diagnosis age sex  \n",
       "0    2022-03-17T12:53:53.415     MELANOMA  63   F  \n",
       "1    2022-03-17T12:54:18.995     MELANOMA  61   M  \n",
       "2    2022-03-17T12:54:47.556     NEGATIVE  84   M  \n",
       "3    2022-03-17T12:55:51.533  LUNG_CANCER  73   M  \n",
       "4    2022-03-17T12:58:15.895     NEGATIVE  78   F  \n",
       "..                       ...          ...  ..  ..  \n",
       "528    2022-03-17T21:44:46.9     LYMPHOMA  57   F  \n",
       "529  2022-03-17T21:45:21.106     LYMPHOMA  49   F  \n",
       "530  2022-03-17T21:46:58.057     MELANOMA  78   F  \n",
       "531  2022-03-17T21:50:00.466     NEGATIVE  66   F  \n",
       "532  2022-03-17T21:50:46.509     NEGATIVE  73   M  \n",
       "\n",
       "[533 rows x 20 columns]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "61c8e0df",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "\n",
    "# Define the path to your metadata CSV file\n",
    "output_directory = '../outputs/plotsDAPAtlas'  # Directory to save plots\n",
    "# Ensure the output directory exists\n",
    "os.makedirs(output_directory, exist_ok=True)\n",
    "\n",
    "\n",
    "# Function to plot the distribution of each attribute\n",
    "def plot_attribute_distribution(df, attribute, filename):\n",
    "    if attribute not in df.columns:\n",
    "        print(f\"Attribute {attribute} not found in the dataset.\")\n",
    "        fig, ax = plt.subplots(figsize=(6, 4))\n",
    "        ax.axis('off')\n",
    "        plt.savefig(filename)\n",
    "        plt.close()\n",
    "        return\n",
    "\n",
    "    #fig, ax = plt.subplots(figsize=(6, 4) if attribute == 'age' else (10, 8))\n",
    "    #title_fontsize = 16\n",
    "    #label_fontsize = 14\n",
    "    #tick_fontsize = 12\n",
    "    fig, ax = plt.subplots(figsize=(8, 8))\n",
    "    title_fontsize = 20\n",
    "    label_fontsize = 20\n",
    "    tick_fontsize = 20\n",
    "    if attribute == 'sex':\n",
    "        title = 'gender'\n",
    "    else:\n",
    "        title = attribute.replace('_', ' ').lower()\n",
    "\n",
    "    if attribute == 'age':\n",
    "        # Plot histogram for age without KDE and with a small gap\n",
    "        ax.hist(df[attribute].dropna(), bins=10,\n",
    "                edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_xlim(0, 100)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "    elif attribute == 'diagnosis':\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ').str.lower()\n",
    "        value_counts = value_counts.rename(index={\"negative\": \"no pathology\"})\n",
    "        ax.bar(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Count', fontsize=label_fontsize)\n",
    "        plt.xticks(rotation=45, ha='right', fontsize=tick_fontsize)\n",
    "    elif attribute in ['pathology_location', 'scanner_model']:\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        ax.barh(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel('Count', fontsize=label_fontsize)\n",
    "        ax.set_ylabel(title, fontsize=label_fontsize)\n",
    "        plt.tight_layout()\n",
    "    elif df[attribute].dtype == 'object':\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        ax.bar(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Count', fontsize=label_fontsize)\n",
    "        plt.xticks(rotation=45, ha='right', fontsize=tick_fontsize)\n",
    "    else:\n",
    "        ax.hist(df[attribute].dropna(), bins=20, edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "\n",
    "    ax.tick_params(axis='both', which='major', labelsize=tick_fontsize)\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(filename)\n",
    "    plt.close()\n",
    "\n",
    "# List of attributes to plot\n",
    "attributes = ['Manufacturer', 'sex', 'age', 'diagnosis']\n",
    "\n",
    "# Generate and save individual plots for each attribute\n",
    "for attribute in attributes:\n",
    "    plot_filename = os.path.join(output_directory, f\"{attribute}_distribution.png\")\n",
    "    plot_attribute_distribution(df, attribute, plot_filename)\n",
    "\n",
    "# Combine all plots into one big image\n",
    "fig, axes = plt.subplots(nrows=(len(attributes) + 2) // 3, ncols=3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for i, attribute in enumerate(attributes):\n",
    "    img = plt.imread(os.path.join(output_directory, f\"{attribute}_distribution.png\"))\n",
    "    axes[i].imshow(img)\n",
    "    axes[i].axis('off')\n",
    "    # Removed setting title here to avoid duplication\n",
    "\n",
    "# Remove any unused subplots\n",
    "for j in range(i + 1, len(axes)):\n",
    "    axes[j].axis('off')\n",
    "\n",
    "plt.tight_layout()\n",
    "combined_plot_path = os.path.join(output_directory, \"combined_distributions.png\")\n",
    "plt.savefig(combined_plot_path)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6bacef77",
   "metadata": {},
   "source": [
    "# Divide by groups"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "73b50a64",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unrecognized value for sex:  nan\n",
      "Unrecognized value for sex:  nan\n",
      "Unrecognized value for age:  16\n",
      "Unrecognized value for sex:  nan\n",
      "Unrecognized value for age:  17\n"
     ]
    }
   ],
   "source": [
    "gender={'male':[],\n",
    "        'female':[]}\n",
    "ages={'18-29':[],\n",
    "      '30-39':[],\n",
    "      '40-49':[],\n",
    "      '50-59':[],\n",
    "      '60-69':[],\n",
    "      '70-79':[],\n",
    "      '80-89':[],\n",
    "      '90-99':[],\n",
    "     }\n",
    "diagnosis={'negative':[],\n",
    "           'melanoma':[],\n",
    "           'lymphoma':[],\n",
    "           'lung cancer':[],}\n",
    "\n",
    "cancer={'negative':[],\n",
    "        'cancer':[]}\n",
    "\n",
    "for index, row in df.iterrows():\n",
    "    tmp=False\n",
    "    for key in ages:\n",
    "        if (row['age']>=int(key[:2]) and row['age']<=int(key[-2:])):\n",
    "            ages[key].append(get_AutoPetName(row['File Location']))\n",
    "            tmp=True\n",
    "    if not tmp:\n",
    "        print('Unrecognized value for age: ',row['age'])\n",
    "    if row['sex']=='M':\n",
    "        gender['male'].append(get_AutoPetName(row['File Location']))\n",
    "    elif row['sex']=='F':\n",
    "        gender['female'].append(get_AutoPetName(row['File Location']))\n",
    "    else:\n",
    "        print('Unrecognized value for sex: ',row['sex'])\n",
    "    if row['diagnosis']=='MELANOMA':\n",
    "        diagnosis['melanoma'].append(get_AutoPetName(row['File Location']))\n",
    "        cancer['cancer'].append(get_AutoPetName(row['File Location']))\n",
    "    elif row['diagnosis']=='LYMPHOMA':\n",
    "        diagnosis['lymphoma'].append(get_AutoPetName(row['File Location']))\n",
    "        cancer['cancer'].append(get_AutoPetName(row['File Location']))\n",
    "    elif row['diagnosis']=='LUNG_CANCER':\n",
    "        diagnosis['lung cancer'].append(get_AutoPetName(row['File Location']))\n",
    "        cancer['cancer'].append(get_AutoPetName(row['File Location']))\n",
    "    elif row['diagnosis']=='NEGATIVE':\n",
    "        diagnosis['negative'].append(get_AutoPetName(row['File Location']))\n",
    "        cancer['negative'].append(get_AutoPetName(row['File Location']))\n",
    "    else:\n",
    "        print('Unrecognized value for diagnosis: ',row['diagnosis'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "04b77ba1",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "530\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in gender:\n",
    "    tmp+=len(gender[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "0131a91e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "533\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in diagnosis:\n",
    "    tmp+=len(diagnosis[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "944250fc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "531\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in ages:\n",
    "    tmp+=len(ages[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "0489af85",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "533\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in cancer:\n",
    "    tmp+=len(cancer[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "4fe8a287",
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "torch.save(gender['male'],output_directory+'/sex_male_autopet.pt')\n",
    "torch.save(gender['female'],output_directory+'/sex_female_autopet.pt')\n",
    "for key in ages:\n",
    "    torch.save(ages[key],output_directory+'/ages_'+key+'_autopet.pt')\n",
    "for key in diagnosis:\n",
    "    torch.save(diagnosis[key],output_directory+'/diagnosis_'+key+'_autopet.pt')\n",
    "for key in cancer:\n",
    "    torch.save(cancer[key],output_directory+'/cancer_diagnosis_'+key+'_autopet.pt')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "893987f8",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:touchstone]",
   "language": "python",
   "name": "conda-env-touchstone-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}




# GroupAnalysis.ipynb


{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "b9c15e14",
   "metadata": {},
   "source": [
    "# Per-class images"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aedb8e98",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "%run ../plot/PerClassBoxplot.py --dataset TotalSegmentator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5afbc039",
   "metadata": {},
   "outputs": [],
   "source": [
    "%run ../plot/PerClassBoxplot.py --dataset TotalSegmentator --test_set_only"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3706f673",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "%run ../plot/PerClassBoxplot.py --dataset DAPAtlas"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2173ed25",
   "metadata": {},
   "source": [
    "### NSD"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e1739d2d",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "%run ../plot/PerClassBoxplot.py --dataset TotalSegmentator --nsd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b29b2ab5",
   "metadata": {},
   "outputs": [],
   "source": [
    "%run ../plot/PerClassBoxplot.py --dataset TotalSegmentator --test_set_only --nsd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "da53a83e",
   "metadata": {},
   "outputs": [],
   "source": [
    "%run ../plot/PerClassBoxplot.py --dataset DAPAtlas --nsd"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cd99de5d",
   "metadata": {},
   "source": [
    "# Dataset Averages TotalSegmentator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a333d9c3",
   "metadata": {},
   "outputs": [],
   "source": [
    "for organ in ['mean','aorta','gall_bladder','kidney_left','kidney_right','liver','pancreas','postcava','spleen','stomach']:\n",
    "    for group in ['all','ages','diagnosis','sex','institute','manufacturer','scanner_model']:\n",
    "        command = f\"../plot/PlotGroup.py --ckpt_root ../totalsegmentator_results/ \\\n",
    "                    --group_root ../outputs/plotsTotalSegmentator/ \\\n",
    "                    --group_name '{group}' --organ '{organ}' --stats \\\n",
    "                    --orientation h --font 20 --fig_length 20\"\n",
    "        get_ipython().run_line_magic('run', command)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8f6d0197",
   "metadata": {},
   "outputs": [],
   "source": [
    "for organ in ['mean','aorta','gall_bladder','kidney_left','kidney_right','liver','pancreas','postcava','spleen','stomach']:\n",
    "    for group in ['all','ages','diagnosis','sex','institute','manufacturer','scanner_model']:\n",
    "        command = f\"../plot/PlotGroup.py --ckpt_root ../totalsegmentator_results/ \\\n",
    "                    --group_root ../outputs/plotsTotalSegmentator/ \\\n",
    "                    --group_name '{group}' --organ '{organ}' --stats --test_set_only \\\n",
    "                    --orientation h --font 20 --fig_length 20\"\n",
    "        get_ipython().run_line_magic('run', command)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e405cb4e",
   "metadata": {},
   "source": [
    "# DAP Atlas group results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0e4edcb2",
   "metadata": {},
   "outputs": [],
   "source": [
    "for group in ['all','ages','diagnosis','sex','cancer_diagnosis']:\n",
    "    for organ in ['mean','aorta','gall_bladder','kidney_left','kidney_right','liver','pancreas','postcava','spleen','stomach']:\n",
    "        command = f\"../plot/PlotGroup.py --ckpt_root ../dapatlas_results/ \\\n",
    "                    --group_root ../outputs/plotsDAPAtlas/ \\\n",
    "                    --group_name '{group}' --organ '{organ}' --stats \\\n",
    "                    --orientation h --font 20 --fig_length 20\"\n",
    "        get_ipython().run_line_magic('run', command)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "612e001c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:statenv]",
   "language": "python",
   "name": "conda-env-statenv-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}


# TotalSegmentatorMetadata.ipynb


{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "48eafd8e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "180a42d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "\n",
    "# Define the path to your metadata CSV file\n",
    "metadata_file = '../utils/metaTotalSeg.csv'  # replace with the actual path to your CSV file\n",
    "output_directory = '../outputs/plotsTotalSegmentator'  # Directory to save plots\n",
    "\n",
    "# Ensure the output directory exists\n",
    "os.makedirs(output_directory, exist_ok=True)\n",
    "\n",
    "# Try reading the CSV file with better error handling\n",
    "df = pd.read_csv(metadata_file,sep=';')\n",
    "\n",
    "# Function to plot the distribution of each attribute\n",
    "def plot_attribute_distribution(df, attribute, filename):\n",
    "    if attribute not in df.columns:\n",
    "        print(f\"Attribute {attribute} not found in the dataset.\")\n",
    "        fig, ax = plt.subplots(figsize=(6, 4))\n",
    "        ax.axis('off')\n",
    "        plt.savefig(filename)\n",
    "        plt.close()\n",
    "        return\n",
    "\n",
    "    #fig, ax = plt.subplots(figsize=(6, 4) if attribute == 'age' else (10, 8))\n",
    "    #title_fontsize = 16\n",
    "    #label_fontsize = 14\n",
    "    #tick_fontsize = 12\n",
    "    fig, ax = plt.subplots(figsize=(8, 8))\n",
    "    title_fontsize = 20\n",
    "    label_fontsize = 20\n",
    "    tick_fontsize = 20\n",
    "    title = attribute.replace('_', ' ')\n",
    "\n",
    "    if attribute == 'age':\n",
    "        # Plot histogram for age without KDE and with a small gap\n",
    "        ax.hist(df[attribute].dropna(), bins=10,\n",
    "                edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_xlim(0, 100)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "    elif attribute in ['pathology_location', 'scanner_model']:\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        ax.barh(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel('Count', fontsize=label_fontsize)\n",
    "        ax.set_ylabel(title, fontsize=label_fontsize)\n",
    "        plt.tight_layout()\n",
    "    elif df[attribute].dtype == 'object':\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        ax.bar(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Count', fontsize=label_fontsize)\n",
    "        plt.xticks(rotation=45, ha='right', fontsize=tick_fontsize)\n",
    "    else:\n",
    "        ax.hist(df[attribute].dropna(), bins=20, edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "\n",
    "    ax.tick_params(axis='both', which='major', labelsize=tick_fontsize)\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(filename)\n",
    "    plt.close()\n",
    "\n",
    "# List of attributes to plot\n",
    "attributes = ['age', 'gender', 'institute', 'manufacturer', 'scanner_model', 'kvp', 'pathology', 'pathology_location']\n",
    "\n",
    "# Generate and save individual plots for each attribute\n",
    "for attribute in attributes:\n",
    "    plot_filename = os.path.join(output_directory, f\"{attribute}_distribution.png\")\n",
    "    plot_attribute_distribution(df, attribute, plot_filename)\n",
    "\n",
    "# Combine all plots into one big image\n",
    "fig, axes = plt.subplots(nrows=(len(attributes) + 2) // 3, ncols=3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for i, attribute in enumerate(attributes):\n",
    "    img = plt.imread(os.path.join(output_directory, f\"{attribute}_distribution.png\"))\n",
    "    axes[i].imshow(img)\n",
    "    axes[i].axis('off')\n",
    "    # Removed setting title here to avoid duplication\n",
    "\n",
    "# Remove any unused subplots\n",
    "for j in range(i + 1, len(axes)):\n",
    "    axes[j].axis('off')\n",
    "\n",
    "plt.tight_layout()\n",
    "combined_plot_path = os.path.join(output_directory, \"combined_distributions.png\")\n",
    "plt.savefig(combined_plot_path)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b27e842d",
   "metadata": {},
   "source": [
    "# Testing Set Metadata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "f1a954a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "\n",
    "# Define the path to your metadata CSV file\n",
    "metadata_file = '../utils/metaTotalSeg.csv'  # replace with the actual path to your CSV file\n",
    "output_directory = '../outputs/plotsTotalSegmentatorTestSet'  # Directory to save plots\n",
    "\n",
    "# Ensure the output directory exists\n",
    "os.makedirs(output_directory, exist_ok=True)\n",
    "\n",
    "# Try reading the CSV file with better error handling\n",
    "df = pd.read_csv(metadata_file,sep=';')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "1479e21e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>image_id</th>\n",
       "      <th>age</th>\n",
       "      <th>gender</th>\n",
       "      <th>institute</th>\n",
       "      <th>study_type</th>\n",
       "      <th>split</th>\n",
       "      <th>manufacturer</th>\n",
       "      <th>scanner_model</th>\n",
       "      <th>kvp</th>\n",
       "      <th>pathology</th>\n",
       "      <th>pathology_location</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>s1366</td>\n",
       "      <td>50.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>I</td>\n",
       "      <td>ct polytrauma</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>sensation 64</td>\n",
       "      <td>120.0</td>\n",
       "      <td>unclear</td>\n",
       "      <td>unclear</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>s0245</td>\n",
       "      <td>77.0</td>\n",
       "      <td>m</td>\n",
       "      <td>I</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>somatom definition flash</td>\n",
       "      <td>100.0</td>\n",
       "      <td>no_pathology</td>\n",
       "      <td>no_location</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>s0325</td>\n",
       "      <td>65.0</td>\n",
       "      <td>f</td>\n",
       "      <td>I</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>sensation 64</td>\n",
       "      <td>120.0</td>\n",
       "      <td>other</td>\n",
       "      <td>abdomen</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>s0320</td>\n",
       "      <td>80.0</td>\n",
       "      <td>m</td>\n",
       "      <td>I</td>\n",
       "      <td>ct angiography abdomen-pelvis-leg</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>sensation 64</td>\n",
       "      <td>120.0</td>\n",
       "      <td>vascular</td>\n",
       "      <td>abdomen</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>s0193</td>\n",
       "      <td>63.0</td>\n",
       "      <td>m</td>\n",
       "      <td>C</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>emotion 16</td>\n",
       "      <td>130.0</td>\n",
       "      <td>no_pathology</td>\n",
       "      <td>no_location</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1223</th>\n",
       "      <td>s1425</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1224</th>\n",
       "      <td>s1426</td>\n",
       "      <td>68.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>lightspeed pro 16</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1225</th>\n",
       "      <td>s1427</td>\n",
       "      <td>23.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>lightspeed16</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1226</th>\n",
       "      <td>s1428</td>\n",
       "      <td>66.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>discovery mi</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1227</th>\n",
       "      <td>s1429</td>\n",
       "      <td>24.0</td>\n",
       "      <td>f</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>optima ct680 series</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>1228 rows × 11 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "     image_id   age gender institute                         study_type  \\\n",
       "0       s1366  50.0    NaN         I                      ct polytrauma   \n",
       "1       s0245  77.0      m         I                  ct abdomen-pelvis   \n",
       "2       s0325  65.0      f         I                  ct abdomen-pelvis   \n",
       "3       s0320  80.0      m         I  ct angiography abdomen-pelvis-leg   \n",
       "4       s0193  63.0      m         C                  ct abdomen-pelvis   \n",
       "...       ...   ...    ...       ...                                ...   \n",
       "1223    s1425   NaN    NaN       NaN                                NaN   \n",
       "1224    s1426  68.0      m       NaN                                NaN   \n",
       "1225    s1427  23.0      m       NaN                                NaN   \n",
       "1226    s1428  66.0      m       NaN                                NaN   \n",
       "1227    s1429  24.0      f       NaN                                NaN   \n",
       "\n",
       "      split manufacturer             scanner_model    kvp     pathology  \\\n",
       "0     train      siemens              sensation 64  120.0       unclear   \n",
       "1     train      siemens  somatom definition flash  100.0  no_pathology   \n",
       "2     train      siemens              sensation 64  120.0         other   \n",
       "3     train      siemens              sensation 64  120.0      vascular   \n",
       "4     train      siemens                emotion 16  130.0  no_pathology   \n",
       "...     ...          ...                       ...    ...           ...   \n",
       "1223   test          NaN                       NaN    NaN           NaN   \n",
       "1224   test           ge         lightspeed pro 16  120.0           NaN   \n",
       "1225   test           ge              lightspeed16  120.0           NaN   \n",
       "1226   test           ge              discovery mi  120.0           NaN   \n",
       "1227   test           ge       optima ct680 series  120.0           NaN   \n",
       "\n",
       "     pathology_location  \n",
       "0               unclear  \n",
       "1           no_location  \n",
       "2               abdomen  \n",
       "3               abdomen  \n",
       "4           no_location  \n",
       "...                 ...  \n",
       "1223                NaN  \n",
       "1224                NaN  \n",
       "1225                NaN  \n",
       "1226                NaN  \n",
       "1227                NaN  \n",
       "\n",
       "[1228 rows x 11 columns]"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "60d6dcbb",
   "metadata": {},
   "outputs": [],
   "source": [
    "original=df\n",
    "df = pd.DataFrame(columns=original.columns)\n",
    "for index, row in original.iterrows():\n",
    "    if row['split']=='test':\n",
    "        df = df.append(row)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "3e8af3db",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>image_id</th>\n",
       "      <th>age</th>\n",
       "      <th>gender</th>\n",
       "      <th>institute</th>\n",
       "      <th>study_type</th>\n",
       "      <th>split</th>\n",
       "      <th>manufacturer</th>\n",
       "      <th>scanner_model</th>\n",
       "      <th>kvp</th>\n",
       "      <th>pathology</th>\n",
       "      <th>pathology_location</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>16</th>\n",
       "      <td>s0295</td>\n",
       "      <td>49.0</td>\n",
       "      <td>f</td>\n",
       "      <td>C</td>\n",
       "      <td>ct spine</td>\n",
       "      <td>test</td>\n",
       "      <td>siemens</td>\n",
       "      <td>emotion 16</td>\n",
       "      <td>130.0</td>\n",
       "      <td>no_pathology</td>\n",
       "      <td>no_location</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>17</th>\n",
       "      <td>s0311</td>\n",
       "      <td>55.0</td>\n",
       "      <td>m</td>\n",
       "      <td>C</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>test</td>\n",
       "      <td>siemens</td>\n",
       "      <td>emotion 16</td>\n",
       "      <td>130.0</td>\n",
       "      <td>no_pathology</td>\n",
       "      <td>no_location</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>29</th>\n",
       "      <td>s0308</td>\n",
       "      <td>62.0</td>\n",
       "      <td>m</td>\n",
       "      <td>I</td>\n",
       "      <td>ct angiography abdomen-pelvis-leg</td>\n",
       "      <td>test</td>\n",
       "      <td>siemens</td>\n",
       "      <td>somatom definition as+</td>\n",
       "      <td>120.0</td>\n",
       "      <td>bleeding</td>\n",
       "      <td>abdomen</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>36</th>\n",
       "      <td>s0291</td>\n",
       "      <td>65.0</td>\n",
       "      <td>f</td>\n",
       "      <td>C</td>\n",
       "      <td>ct neck-thorax-abdomen-pelvis</td>\n",
       "      <td>test</td>\n",
       "      <td>siemens</td>\n",
       "      <td>emotion 16</td>\n",
       "      <td>130.0</td>\n",
       "      <td>tumor</td>\n",
       "      <td>bones</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>68</th>\n",
       "      <td>s0235</td>\n",
       "      <td>44.0</td>\n",
       "      <td>f</td>\n",
       "      <td>I</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>test</td>\n",
       "      <td>siemens</td>\n",
       "      <td>somatom definition flash</td>\n",
       "      <td>100.0</td>\n",
       "      <td>vascular</td>\n",
       "      <td>unclear</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1223</th>\n",
       "      <td>s1425</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1224</th>\n",
       "      <td>s1426</td>\n",
       "      <td>68.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>lightspeed pro 16</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1225</th>\n",
       "      <td>s1427</td>\n",
       "      <td>23.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>lightspeed16</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1226</th>\n",
       "      <td>s1428</td>\n",
       "      <td>66.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>discovery mi</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1227</th>\n",
       "      <td>s1429</td>\n",
       "      <td>24.0</td>\n",
       "      <td>f</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>optima ct680 series</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>89 rows × 11 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "     image_id   age gender institute                         study_type split  \\\n",
       "16      s0295  49.0      f         C                           ct spine  test   \n",
       "17      s0311  55.0      m         C                  ct abdomen-pelvis  test   \n",
       "29      s0308  62.0      m         I  ct angiography abdomen-pelvis-leg  test   \n",
       "36      s0291  65.0      f         C      ct neck-thorax-abdomen-pelvis  test   \n",
       "68      s0235  44.0      f         I                  ct abdomen-pelvis  test   \n",
       "...       ...   ...    ...       ...                                ...   ...   \n",
       "1223    s1425   NaN    NaN       NaN                                NaN  test   \n",
       "1224    s1426  68.0      m       NaN                                NaN  test   \n",
       "1225    s1427  23.0      m       NaN                                NaN  test   \n",
       "1226    s1428  66.0      m       NaN                                NaN  test   \n",
       "1227    s1429  24.0      f       NaN                                NaN  test   \n",
       "\n",
       "     manufacturer             scanner_model    kvp     pathology  \\\n",
       "16        siemens                emotion 16  130.0  no_pathology   \n",
       "17        siemens                emotion 16  130.0  no_pathology   \n",
       "29        siemens    somatom definition as+  120.0      bleeding   \n",
       "36        siemens                emotion 16  130.0         tumor   \n",
       "68        siemens  somatom definition flash  100.0      vascular   \n",
       "...           ...                       ...    ...           ...   \n",
       "1223          NaN                       NaN    NaN           NaN   \n",
       "1224           ge         lightspeed pro 16  120.0           NaN   \n",
       "1225           ge              lightspeed16  120.0           NaN   \n",
       "1226           ge              discovery mi  120.0           NaN   \n",
       "1227           ge       optima ct680 series  120.0           NaN   \n",
       "\n",
       "     pathology_location  \n",
       "16          no_location  \n",
       "17          no_location  \n",
       "29              abdomen  \n",
       "36                bones  \n",
       "68              unclear  \n",
       "...                 ...  \n",
       "1223                NaN  \n",
       "1224                NaN  \n",
       "1225                NaN  \n",
       "1226                NaN  \n",
       "1227                NaN  \n",
       "\n",
       "[89 rows x 11 columns]"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6eeffd63",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to plot the distribution of each attribute\n",
    "def plot_attribute_distribution(df, attribute, filename):\n",
    "    if attribute not in df.columns:\n",
    "        print(f\"Attribute {attribute} not found in the dataset.\")\n",
    "        fig, ax = plt.subplots(figsize=(6, 4))\n",
    "        ax.axis('off')\n",
    "        plt.savefig(filename)\n",
    "        plt.close()\n",
    "        return\n",
    "\n",
    "    #fig, ax = plt.subplots(figsize=(6, 4) if attribute == 'age' else (10, 8))\n",
    "    #title_fontsize = 16\n",
    "    #label_fontsize = 14\n",
    "    #tick_fontsize = 12\n",
    "    fig, ax = plt.subplots(figsize=(8, 8))\n",
    "    title_fontsize = 20\n",
    "    label_fontsize = 20\n",
    "    tick_fontsize = 20\n",
    "    title = attribute.replace('_', ' ')\n",
    "\n",
    "    if attribute == 'age':\n",
    "        # Plot histogram for age without KDE and with a small gap\n",
    "        ax.hist(df[attribute].dropna(), bins=10,\n",
    "                edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_xlim(0, 100)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "    elif attribute in ['pathology_location', 'scanner_model']:\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        ax.barh(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel('Count', fontsize=label_fontsize)\n",
    "        ax.set_ylabel(title, fontsize=label_fontsize)\n",
    "        plt.tight_layout()\n",
    "    elif df[attribute].dtype == 'object':\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        try:\n",
    "            value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        except:\n",
    "            print(value_counts.index)\n",
    "        ax.bar(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Count', fontsize=label_fontsize)\n",
    "        plt.xticks(rotation=45, ha='right', fontsize=tick_fontsize)\n",
    "    else:\n",
    "        ax.hist(df[attribute].dropna(), bins=20, edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "\n",
    "    ax.tick_params(axis='both', which='major', labelsize=tick_fontsize)\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(filename)\n",
    "    plt.close()\n",
    "\n",
    "# List of attributes to plot\n",
    "attributes = ['age', 'gender', 'institute', 'manufacturer', 'scanner_model',\n",
    "              'kvp', 'pathology', 'pathology_location']\n",
    "\n",
    "# Generate and save individual plots for each attribute\n",
    "for attribute in attributes:\n",
    "    plot_filename = os.path.join(output_directory, f\"{attribute}_distribution.png\")\n",
    "    plot_attribute_distribution(df, attribute, plot_filename)\n",
    "\n",
    "# Combine all plots into one big image\n",
    "fig, axes = plt.subplots(nrows=(len(attributes) + 2) // 3, ncols=3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for i, attribute in enumerate(attributes):\n",
    "    img = plt.imread(os.path.join(output_directory, f\"{attribute}_distribution.png\"))\n",
    "    axes[i].imshow(img)\n",
    "    axes[i].axis('off')\n",
    "    # Removed setting title here to avoid duplication\n",
    "\n",
    "# Remove any unused subplots\n",
    "for j in range(i + 1, len(axes)):\n",
    "    axes[j].axis('off')\n",
    "\n",
    "plt.tight_layout()\n",
    "combined_plot_path = os.path.join(output_directory, \"combined_distributions.png\")\n",
    "plt.savefig(combined_plot_path)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "889e1e19",
   "metadata": {},
   "source": [
    "# Training set meatadata"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7388b2cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "\n",
    "# Define the path to your metadata CSV file\n",
    "metadata_file = '../utils/metaTotalSeg.csv'  # replace with the actual path to your CSV file\n",
    "output_directory = '../outputs/plotsTotalSegmentatorTrainSet'  # Directory to save plots\n",
    "\n",
    "# Ensure the output directory exists\n",
    "os.makedirs(output_directory, exist_ok=True)\n",
    "\n",
    "# Try reading the CSV file with better error handling\n",
    "df = pd.read_csv(metadata_file,sep=';')\n",
    "\n",
    "original=df\n",
    "df = pd.DataFrame(columns=original.columns)\n",
    "for index, row in original.iterrows():\n",
    "    if row['split']=='train':\n",
    "        df = df.append(row)\n",
    "\n",
    "# Function to plot the distribution of each attribute\n",
    "def plot_attribute_distribution(df, attribute, filename):\n",
    "    if attribute not in df.columns:\n",
    "        print(f\"Attribute {attribute} not found in the dataset.\")\n",
    "        fig, ax = plt.subplots(figsize=(6, 4))\n",
    "        ax.axis('off')\n",
    "        plt.savefig(filename)\n",
    "        plt.close()\n",
    "        return\n",
    "\n",
    "    #fig, ax = plt.subplots(figsize=(6, 4) if attribute == 'age' else (10, 8))\n",
    "    #title_fontsize = 16\n",
    "    #label_fontsize = 14\n",
    "    #tick_fontsize = 12\n",
    "    fig, ax = plt.subplots(figsize=(8, 8))\n",
    "    title_fontsize = 20\n",
    "    label_fontsize = 20\n",
    "    tick_fontsize = 20\n",
    "    title = attribute.replace('_', ' ')\n",
    "\n",
    "    if attribute == 'age':\n",
    "        # Plot histogram for age without KDE and with a small gap\n",
    "        ax.hist(df[attribute].dropna(), bins=10,\n",
    "                edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_xlim(0, 100)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "    elif attribute in ['pathology_location', 'scanner_model']:\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        ax.barh(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel('Count', fontsize=label_fontsize)\n",
    "        ax.set_ylabel(title, fontsize=label_fontsize)\n",
    "        plt.tight_layout()\n",
    "    elif df[attribute].dtype == 'object':\n",
    "        value_counts = df[attribute].value_counts()\n",
    "        try:\n",
    "            value_counts.index = value_counts.index.str.replace('_', ' ')\n",
    "        except:\n",
    "            print(value_counts.index)\n",
    "        ax.bar(value_counts.index, value_counts.values, color='lightblue', edgecolor='black')\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Count', fontsize=label_fontsize)\n",
    "        plt.xticks(rotation=45, ha='right', fontsize=tick_fontsize)\n",
    "    else:\n",
    "        ax.hist(df[attribute].dropna(), bins=20, edgecolor='black', color='lightblue', rwidth=0.8)\n",
    "        ax.set_title(f'{title}', fontsize=title_fontsize)\n",
    "        ax.set_xlabel(title, fontsize=label_fontsize)\n",
    "        ax.set_ylabel('Frequency', fontsize=label_fontsize)\n",
    "\n",
    "    ax.tick_params(axis='both', which='major', labelsize=tick_fontsize)\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(filename)\n",
    "    plt.close()\n",
    "\n",
    "# List of attributes to plot\n",
    "attributes = ['age', 'gender', 'institute', 'manufacturer', 'scanner_model',\n",
    "              'kvp', 'pathology', 'pathology_location']\n",
    "\n",
    "# Generate and save individual plots for each attribute\n",
    "for attribute in attributes:\n",
    "    plot_filename = os.path.join(output_directory, f\"{attribute}_distribution.png\")\n",
    "    plot_attribute_distribution(df, attribute, plot_filename)\n",
    "\n",
    "# Combine all plots into one big image\n",
    "fig, axes = plt.subplots(nrows=(len(attributes) + 2) // 3, ncols=3, figsize=(18, 12))\n",
    "axes = axes.flatten()\n",
    "\n",
    "for i, attribute in enumerate(attributes):\n",
    "    img = plt.imread(os.path.join(output_directory, f\"{attribute}_distribution.png\"))\n",
    "    axes[i].imshow(img)\n",
    "    axes[i].axis('off')\n",
    "    # Removed setting title here to avoid duplication\n",
    "\n",
    "# Remove any unused subplots\n",
    "for j in range(i + 1, len(axes)):\n",
    "    axes[j].axis('off')\n",
    "\n",
    "plt.tight_layout()\n",
    "combined_plot_path = os.path.join(output_directory, \"combined_distributions.png\")\n",
    "plt.savefig(combined_plot_path)\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f5d2d10a",
   "metadata": {},
   "source": [
    "# Divide by groups"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "6c811bcf",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the path to your metadata CSV file\n",
    "metadata_file = '../utils/metaTotalSeg.csv'  # replace with the actual path to your CSV file\n",
    "output_directory = '../outputs/plotsTotalSegmentator'  # Directory to save plots\n",
    "\n",
    "# Ensure the output directory exists\n",
    "os.makedirs(output_directory, exist_ok=True)\n",
    "\n",
    "# Try reading the CSV file with better error handling\n",
    "df = pd.read_csv(metadata_file,sep=';')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "d1a85abf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>image_id</th>\n",
       "      <th>age</th>\n",
       "      <th>gender</th>\n",
       "      <th>institute</th>\n",
       "      <th>study_type</th>\n",
       "      <th>split</th>\n",
       "      <th>manufacturer</th>\n",
       "      <th>scanner_model</th>\n",
       "      <th>kvp</th>\n",
       "      <th>pathology</th>\n",
       "      <th>pathology_location</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>s1366</td>\n",
       "      <td>50.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>I</td>\n",
       "      <td>ct polytrauma</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>sensation 64</td>\n",
       "      <td>120.0</td>\n",
       "      <td>unclear</td>\n",
       "      <td>unclear</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>s0245</td>\n",
       "      <td>77.0</td>\n",
       "      <td>m</td>\n",
       "      <td>I</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>somatom definition flash</td>\n",
       "      <td>100.0</td>\n",
       "      <td>no_pathology</td>\n",
       "      <td>no_location</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>s0325</td>\n",
       "      <td>65.0</td>\n",
       "      <td>f</td>\n",
       "      <td>I</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>sensation 64</td>\n",
       "      <td>120.0</td>\n",
       "      <td>other</td>\n",
       "      <td>abdomen</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>s0320</td>\n",
       "      <td>80.0</td>\n",
       "      <td>m</td>\n",
       "      <td>I</td>\n",
       "      <td>ct angiography abdomen-pelvis-leg</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>sensation 64</td>\n",
       "      <td>120.0</td>\n",
       "      <td>vascular</td>\n",
       "      <td>abdomen</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>s0193</td>\n",
       "      <td>63.0</td>\n",
       "      <td>m</td>\n",
       "      <td>C</td>\n",
       "      <td>ct abdomen-pelvis</td>\n",
       "      <td>train</td>\n",
       "      <td>siemens</td>\n",
       "      <td>emotion 16</td>\n",
       "      <td>130.0</td>\n",
       "      <td>no_pathology</td>\n",
       "      <td>no_location</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>...</th>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "      <td>...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1223</th>\n",
       "      <td>s1425</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1224</th>\n",
       "      <td>s1426</td>\n",
       "      <td>68.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>lightspeed pro 16</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1225</th>\n",
       "      <td>s1427</td>\n",
       "      <td>23.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>lightspeed16</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1226</th>\n",
       "      <td>s1428</td>\n",
       "      <td>66.0</td>\n",
       "      <td>m</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>discovery mi</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1227</th>\n",
       "      <td>s1429</td>\n",
       "      <td>24.0</td>\n",
       "      <td>f</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "      <td>test</td>\n",
       "      <td>ge</td>\n",
       "      <td>optima ct680 series</td>\n",
       "      <td>120.0</td>\n",
       "      <td>NaN</td>\n",
       "      <td>NaN</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "<p>1228 rows × 11 columns</p>\n",
       "</div>"
      ],
      "text/plain": [
       "     image_id   age gender institute                         study_type  \\\n",
       "0       s1366  50.0    NaN         I                      ct polytrauma   \n",
       "1       s0245  77.0      m         I                  ct abdomen-pelvis   \n",
       "2       s0325  65.0      f         I                  ct abdomen-pelvis   \n",
       "3       s0320  80.0      m         I  ct angiography abdomen-pelvis-leg   \n",
       "4       s0193  63.0      m         C                  ct abdomen-pelvis   \n",
       "...       ...   ...    ...       ...                                ...   \n",
       "1223    s1425   NaN    NaN       NaN                                NaN   \n",
       "1224    s1426  68.0      m       NaN                                NaN   \n",
       "1225    s1427  23.0      m       NaN                                NaN   \n",
       "1226    s1428  66.0      m       NaN                                NaN   \n",
       "1227    s1429  24.0      f       NaN                                NaN   \n",
       "\n",
       "      split manufacturer             scanner_model    kvp     pathology  \\\n",
       "0     train      siemens              sensation 64  120.0       unclear   \n",
       "1     train      siemens  somatom definition flash  100.0  no_pathology   \n",
       "2     train      siemens              sensation 64  120.0         other   \n",
       "3     train      siemens              sensation 64  120.0      vascular   \n",
       "4     train      siemens                emotion 16  130.0  no_pathology   \n",
       "...     ...          ...                       ...    ...           ...   \n",
       "1223   test          NaN                       NaN    NaN           NaN   \n",
       "1224   test           ge         lightspeed pro 16  120.0           NaN   \n",
       "1225   test           ge              lightspeed16  120.0           NaN   \n",
       "1226   test           ge              discovery mi  120.0           NaN   \n",
       "1227   test           ge       optima ct680 series  120.0           NaN   \n",
       "\n",
       "     pathology_location  \n",
       "0               unclear  \n",
       "1           no_location  \n",
       "2               abdomen  \n",
       "3               abdomen  \n",
       "4           no_location  \n",
       "...                 ...  \n",
       "1223                NaN  \n",
       "1224                NaN  \n",
       "1225                NaN  \n",
       "1226                NaN  \n",
       "1227                NaN  \n",
       "\n",
       "[1228 rows x 11 columns]"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2b827441",
   "metadata": {},
   "outputs": [],
   "source": [
    "gender={'male':[],\n",
    "        'female':[]}\n",
    "ages={'18-29':[],\n",
    "      '30-39':[],\n",
    "      '40-49':[],\n",
    "      '50-59':[],\n",
    "      '60-69':[],\n",
    "      '70-79':[],\n",
    "      '80-89':[],\n",
    "      '90-99':[],\n",
    "     }\n",
    "diagnosis={'no_pathology':[],\n",
    "           'tumor':[],\n",
    "           'unclear':[],\n",
    "           'vascular':[],\n",
    "           'trauma':[],\n",
    "           'inflammation':[],\n",
    "           'bleeding':[],\n",
    "           'other':[]}\n",
    "manufacturer={}\n",
    "scanner_model={}\n",
    "institute={}\n",
    "\n",
    "for index, row in df.iterrows():\n",
    "    tmp=False\n",
    "    for key in ages:\n",
    "        if (row['age']>=int(key[:2]) and row['age']<=int(key[-2:])):\n",
    "            ages[key].append(row['image_id'])\n",
    "            tmp=True\n",
    "    if not tmp:\n",
    "        print('Unrecognized value for age: ',row['age'])\n",
    "    if row['gender']=='m':\n",
    "        gender['male'].append(row['image_id'])\n",
    "    elif row['gender']=='f':\n",
    "        gender['female'].append(row['image_id'])\n",
    "    else:\n",
    "        print('Unrecognized value for sex: ',row['gender'])\n",
    "    tmp2=False\n",
    "    for key in diagnosis:\n",
    "        if row['pathology']==key:\n",
    "            diagnosis[key].append(row['image_id'])\n",
    "            tmp2=True\n",
    "    if not tmp2:\n",
    "        print('Unrecognized value for diagnosis: ',row['pathology'])\n",
    "    if row['manufacturer'] not in list(manufacturer.keys()):\n",
    "        manufacturer[row['manufacturer']]=[]\n",
    "    if row['scanner_model'] not in list(scanner_model.keys()):\n",
    "        scanner_model[row['scanner_model']]=[]\n",
    "    if row['institute'] not in list(institute.keys()):\n",
    "        institute[row['institute']]=[]\n",
    "    manufacturer[row['manufacturer']].append(row['image_id'])\n",
    "    scanner_model[row['scanner_model']].append(row['image_id'])\n",
    "    institute[row['institute']].append(row['image_id'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "16d0582f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1226\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in gender:\n",
    "    tmp+=len(gender[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "baf603d9",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1204\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in diagnosis:\n",
    "    tmp+=len(diagnosis[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "90bbfbea",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1225\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in ages:\n",
    "    tmp+=len(ages[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "2bf0f019",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1228\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in manufacturer:\n",
    "    tmp+=len(manufacturer[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "950ef985",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1228\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in scanner_model:\n",
    "    tmp+=len(scanner_model[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "9cb06eef",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1228\n"
     ]
    }
   ],
   "source": [
    "tmp=0\n",
    "for key in institute:\n",
    "    tmp+=len(institute[key])\n",
    "print(tmp)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "3f491630",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['siemens', 'ge', nan, 'philips'])"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "manufacturer.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "358efba9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['I', 'C', 'B', 'A', 'G', 'J', 'E', 'H', 'F', 'D', nan])"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "institute.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "ca2fcf88",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['sensation 64', 'somatom definition flash', 'emotion 16', 'somatom definition as+', 'sensation 16', 'discovery ste', nan, 'sensation 10', 'somatom definition edge', 'ingenuity core 128', 'lightspeed vct', 'iqon - spectral ct', 'somatom definition as', 'brilliance 64', 'somatom force', 'somatom go.top', 'biograph128', 'lightspeed pro 16', 'lightspeed16', 'discovery mi', 'optima ct680 series'])"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "scanner_model.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "2a343530",
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "torch.save(gender['male'],output_directory+'/sex_male_totalsegmentator.pt')\n",
    "torch.save(gender['female'],output_directory+'/sex_female_totalsegmentator.pt')\n",
    "for key in ages:\n",
    "    torch.save(ages[key],output_directory+'/ages_'+key+'_totalsegmentator.pt')\n",
    "for key in diagnosis:\n",
    "    if isinstance(key,str):\n",
    "        torch.save(diagnosis[key],output_directory+'/diagnosis_'+key+'_totalsegmentator.pt')\n",
    "for key in manufacturer:\n",
    "    if isinstance(key,str):\n",
    "        torch.save(manufacturer[key],output_directory+'/manufacturer_'+key+'_totalsegmentator.pt')\n",
    "for key in institute:\n",
    "    if isinstance(key,str):\n",
    "        torch.save(institute[key],output_directory+'/institute_'+key+'_totalsegmentator.pt')\n",
    "for key in scanner_model:\n",
    "    if isinstance(key,str):\n",
    "        torch.save(scanner_model[key],output_directory+'/scanner_model_'+key+'_totalsegmentator.pt')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9af309de",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:touchstone]",
   "language": "python",
   "name": "conda-env-touchstone-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}



# AggregatedBoxplot.py

import matplotlib.pyplot as plt
from PlotGroup import read_models_and_groups, create_long_format_dataframe, create_boxplot
import matplotlib.gridspec as gridspec
from argparse import Namespace
import argparse
import os

def parse_arguments():
    parser = argparse.ArgumentParser(description='Generate dot and boxplots with confidence intervals.')
    parser.add_argument('--ckpt_root_TotalSegmentator', type=str, help='Path to the directory containing model result CSV files',default='../totalsegmentator_results/')
    parser.add_argument('--ckpt_root_JHH', type=str, help='Path to the directory containing model result CSV files',default='PrivateGT/')
    parser.add_argument('--ckpt_root_DAPAtlas', type=str, help='Path to the directory containing model result CSV files',default='../dapatlas_results/')
    parser.add_argument('--group_root_TotalSegmentator', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotsTotalSegmentator/')
    parser.add_argument('--group_root_DAPAtlas', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotsDAPAtlas/')
    parser.add_argument('--group_root_JHH', type=str, help='Path to the directory containing group sample lists',default='plotJHH/')
    parser.add_argument('--nsd', action='store_true', help='Plot dice if not set', default=False)
    parser.add_argument('--stats', action='store_true', help='Plot only results for nnU-Net and for average of all models', default=False)
    return parser.parse_args()


def create_multiple_boxplots(args):
    fig = plt.figure(figsize=(21, 29.7))

    gs = gridspec.GridSpec(45, 2, figure=fig, hspace=0.45, wspace=0.3)

    # Define subplots in custom locations
    ts_age = fig.add_subplot(gs[0:8, 0])
    ts_institute = fig.add_subplot(gs[9:15, 0])

    ts_diag = fig.add_subplot(gs[0:8, 1])
    ts_sex = fig.add_subplot(gs[9:11, 1])
    ts_manu = fig.add_subplot(gs[12:15, 1])

    dap_age = fig.add_subplot(gs[16:23, 0])

    dap_diag = fig.add_subplot(gs[17:19, 1])
    dap_sex = fig.add_subplot(gs[20:22, 1])

    JHH_age = fig.add_subplot(gs[24:31, 0])

    JHH_diag = fig.add_subplot(gs[23:25, 1])
    JHH_sex  = fig.add_subplot(gs[26:28, 1])
    JHH_race  = fig.add_subplot(gs[29:32, 1])

    # Add "DAP Atlas" text in cell 16
    #fig.text(0, 0, "DAP Atlas", fontsize=20, ha='left', va='center', rotation=90)

    configs=[{'group_name':'ages','ckpt_root':args.ckpt_root_TotalSegmentator,
              'group_root':args.group_root_TotalSegmentator,'subplot':ts_age,
              'limits':None},
             {'group_name':'diagnosis','ckpt_root':args.ckpt_root_TotalSegmentator,
              'group_root':args.group_root_TotalSegmentator,'subplot':ts_diag,
              'limits':None},
             {'group_name':'manufacturer','ckpt_root':args.ckpt_root_TotalSegmentator,
              'group_root':args.group_root_TotalSegmentator,'subplot':ts_manu,
              'limits':None},
             {'group_name':'sex','ckpt_root':args.ckpt_root_TotalSegmentator,
              'group_root':args.group_root_TotalSegmentator,'subplot':ts_sex,
              'limits':None},
             {'group_name':'institute','ckpt_root':args.ckpt_root_TotalSegmentator,
              'group_root':args.group_root_TotalSegmentator,'subplot':ts_institute,
              'limits':None},
             {'group_name':'ages','ckpt_root':args.ckpt_root_DAPAtlas,
              'group_root':args.group_root_DAPAtlas,'subplot':dap_age,
              'limits':[0.75,1]},
             {'group_name':'cancer_diagnosis','ckpt_root':args.ckpt_root_DAPAtlas,
              'group_root':args.group_root_DAPAtlas,'subplot':dap_diag,
              'limits':[0.75,1]},
             {'group_name':'sex','ckpt_root':args.ckpt_root_DAPAtlas,
              'group_root':args.group_root_DAPAtlas,'subplot':dap_sex,
              'limits':[0.75,1]},
             #{'group_name':'ages','ckpt_root':args.ckpt_root_JHH,
             # 'group_root':args.group_root_JHH,'subplot':JHH_age,
             # 'limits':[0.7,1]},
             #{'group_name':'sex','ckpt_root':args.ckpt_root_JHH,
             # 'group_root':args.group_root_JHH,'subplot':JHH_sex,
             # 'limits':[0.7,1]},
             #{'group_name':'race','ckpt_root':args.ckpt_root_JHH,
             # 'group_root':args.group_root_JHH,'subplot':JHH_race,
             # 'limits':[0.7,1]},
             #{'group_name':'cancer_diagnosis','ckpt_root':args.ckpt_root_JHH,
             # 'group_root':args.group_root_JHH,'subplot':JHH_diag,
             # 'limits':[0.7,1]}
            ]


    for config in configs:
        p_args = Namespace()
        p_args.group_name=config['group_name']
        p_args.ckpt_root=config['ckpt_root']
        p_args.group_root=config['group_root']
        p_args.nsd=args.nsd
        p_args.organ='mean'
        p_args.mean_and_best=False
        p_args.just_mean=True
        p_args.orientation='h'
        p_args.th=6
        p_args.test_set_only=False
        p_args.stats=args.stats

        results, groups_lists, order, num_groups, num_algos = read_models_and_groups(p_args)
        long_df = create_long_format_dataframe(results, groups_lists, p_args)
        create_boxplot(long_df, order, num_groups, p_args, num_algos, ax=config['subplot'],
                       save=False,limits=config['limits'],hide_model=True,omit_metric=True,
                       colorful=False)


        #configs.subplot.set_title(f'Plot {i + 1}')
        #configs.subplot.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')

    plt.tight_layout()
    os.makedirs('../outputs/',exist_ok=True)
    plt.savefig('../outputs/summary_groups.pdf',bbox_inches='tight', pad_inches=0)
    #plt.show()
    plt.close()

if __name__ == "__main__":
    args = parse_arguments()
    create_multiple_boxplots(args)



# PerClassBoxplot.py


import matplotlib.pyplot as plt
from PlotGroup import read_models_and_groups, create_long_format_dataframe, create_boxplot
import matplotlib.gridspec as gridspec
from argparse import Namespace
import argparse

def parse_arguments():
    parser = argparse.ArgumentParser(description='Generate dot and boxplots with confidence intervals.')
    parser.add_argument('--dataset', type=str, help='name of dataset',default='TotalSegmentator')
    parser.add_argument('--ckpt_root_TotalSegmentator', type=str, help='Path to the directory containing model result CSV files',default='../totalsegmentator_results/')
    parser.add_argument('--ckpt_root_JHH', type=str, help='Path to the directory containing model result CSV files',default='PrivateGT/')
    parser.add_argument('--ckpt_root_DAPAtlas', type=str, help='Path to the directory containing model result CSV files',default='../dapatlas_results/')
    parser.add_argument('--group_root_TotalSegmentator', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotsTotalSegmentator/')
    parser.add_argument('--group_root_DAPAtlas', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotsDAPAtlas/')
    parser.add_argument('--group_root_JHH', type=str, help='Path to the directory containing group sample lists',default='plotJHH/')
    parser.add_argument('--nsd', action='store_true', help='Plot dice if not set', default=False)
    parser.add_argument('--stats', action='store_true', help='Plot only results for nnU-Net and for average of all models', default=False)
    parser.add_argument('--test_set_only', action='store_true', help='Plot only results for nnU-Net and for average of all models', default=False)
    parser.add_argument('--split_path', default='../utils/metaTotalSeg.csv', help='Location of TotalSegmentator metadata')
    return parser.parse_args()


def create_multiple_boxplots(args):
    fig = plt.figure(figsize=(21, 29.7))

    gs = gridspec.GridSpec(3, 3, figure=fig, hspace=0.1, wspace=0.1)

    if args.dataset=='TotalSegmentator':
        group_root=args.group_root_TotalSegmentator
        ckpt_root=args.ckpt_root_TotalSegmentator
    elif args.dataset=='DAPAtlas':
        group_root=args.group_root_DAPAtlas
        ckpt_root=args.ckpt_root_DAPAtlas
    elif args.dataset=='JHH':
        group_root=args.group_root_JHH
        ckpt_root=args.ckpt_root_JHH


    configs=[{'group_name':'all',
              'organ':'spleen',
              'subplot':fig.add_subplot(gs[0, 0]),
              'limits':None},
             {'group_name':'all',
              'organ':'kidney_right',
              'subplot':fig.add_subplot(gs[0, 1]),
              'limits':None},
             {'group_name':'all',
              'organ':'kidney_left',
              'subplot':fig.add_subplot(gs[0, 2]),
              'limits':None},
             {'group_name':'all',
              'organ':'gall_bladder',
              'subplot':fig.add_subplot(gs[1, 0]),
              'limits':None},
             {'group_name':'all',
              'organ':'liver',
              'subplot':fig.add_subplot(gs[1, 1]),
              'limits':None},
             {'group_name':'all',
              'organ':'stomach',
              'subplot':fig.add_subplot(gs[1, 2]),
              'limits':None},
             {'group_name':'all',
              'organ':'aorta',
              'subplot':fig.add_subplot(gs[2, 0]),
              'limits':None},
             {'group_name':'all',
              'organ':'postcava',
              'subplot':fig.add_subplot(gs[2, 1]),
              'limits':None},
             {'group_name':'all',
              'organ':'pancreas',
              'subplot':fig.add_subplot(gs[2, 2]),
              'limits':None}
            ]





    for config in configs:
        p_args = Namespace()
        p_args.group_name=config['group_name']
        p_args.ckpt_root=ckpt_root
        p_args.group_root=group_root
        p_args.nsd=args.nsd
        p_args.organ=config['organ']
        p_args.mean_and_best=False
        p_args.just_mean=False
        p_args.orientation='h'
        p_args.th=6
        p_args.test_set_only=args.test_set_only
        p_args.split_path=args.split_path
        p_args.stats=args.stats

        results, groups_lists, order, num_groups, num_algos = read_models_and_groups(p_args)
        long_df = create_long_format_dataframe(results, groups_lists, p_args)
        create_boxplot(long_df, order, num_groups, p_args, num_algos, ax=config['subplot'],
                       save=False,limits=config['limits'],omit_metric=True,
                       title_style='organ',colorful=False,rotation=0,
                       hide_model=not (config['organ']=='spleen' or config['organ']=='gall_bladder' \
                                   or config['organ']=='aorta'),font=17)


        #configs.subplot.set_title(f'Plot {i + 1}')
        #configs.subplot.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')

    plt.tight_layout()
    filename='../outputs/box_plots/box_plots_per_class_'+args.dataset.replace(' ','_')
    if args.nsd:
        print('NSD')
        filename+='_nsd'
    if args.test_set_only:
        filename+='_official_test_set'
    filename+='.pdf'
    plt.savefig(filename,bbox_inches='tight', pad_inches=0)
    plt.show()

if __name__ == "__main__":
    args = parse_arguments()
    create_multiple_boxplots(args)


# PlotAllSignificanceMaps.py


import matplotlib.pyplot as plt
from PlotGroup import read_models_and_groups, create_long_format_dataframe, create_boxplot
import matplotlib.gridspec as gridspec
from argparse import Namespace
import argparse
import SignificanceMaps as StatisticalHeatmap
import os

def parse_arguments():
    parser = argparse.ArgumentParser(description='Generate dot and boxplots with confidence intervals.')
    parser.add_argument('--ckpt_root_TotalSegmentator', type=str, help='Path to the directory containing model result CSV files',default='../totalsegmentator_results/')
    parser.add_argument('--ckpt_root_DAPAtlas', type=str, help='Path to the directory containing model result CSV files',default='../dapatlas_results/')
    parser.add_argument('--ckpt_root_JHH', type=str, help='Path to the directory containing model result CSV files',default='../PrivateGT/')
    parser.add_argument('--group_root_TotalSegmentator', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotsTotalSegmentator/')
    parser.add_argument('--group_root_DAPAtlas', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotsDAPAtlas/')
    parser.add_argument('--group_root_JHH', type=str, help='Path to the directory containing group sample lists',default='../outputs/plotJHH/')
    parser.add_argument('--nsd', action='store_true', help='Plot dice if not set', default=False)
    parser.add_argument('--split_path', default='../utils/metaTotalSeg.csv', help='Location of TotalSegmentator metadata')
    parser.add_argument('--organs', type=str, help='list of organs',default='spleen kidneyR kidneyL gallbladder liver')
    return parser.parse_args()

organDict={ 'spleen':'spleen',
            'kidneyR':'kidney_right',
            'kidneyL':'kidney_left',
            'gallbladder':'gall_bladder',
            'liver':'liver',
            'stomach':'stomach',
            'aorta':'aorta',
            'IVC':'postcava',
            'pancreas':'pancreas',
            'average':'mean'}

def create_multiple_boxplots(args):
    organs= args.organs.split()

    fig = plt.figure(figsize=(20, 5*len(organs)))

    gs = gridspec.GridSpec(len(organs), 4, figure=fig, hspace=0.7, wspace=0.55)

    # Define subplots in custom locations
    configs=[]
    for i,organ in enumerate(organs,0):
        configs.append( {'title':'TotalSegmentator - '+organ,
                         'ckpt_root':args.ckpt_root_TotalSegmentator,
                         'group_root':args.group_root_TotalSegmentator,
                         'subplot':fig.add_subplot(gs[i, 0]),
                         'test_set_only':False,
                         'organ':organDict[organ]})
        configs.append( {'title':'TotalSegmentator Official Test Set - '+organ,
                         'ckpt_root':args.ckpt_root_TotalSegmentator,
                         'group_root':args.group_root_TotalSegmentator,
                         'subplot':fig.add_subplot(gs[i, 1]),
                         'test_set_only':True,
                         'organ':organDict[organ]})
        configs.append( {'title':'DAP Atlas - '+organ,
                         'ckpt_root':args.ckpt_root_DAPAtlas,
                         'group_root':args.group_root_DAPAtlas,
                         'subplot':fig.add_subplot(gs[i, 2]),
                         'test_set_only':False,
                         'organ':organDict[organ]})
        #configs.append( {'title':'JHH - '+organ,
        #                 'ckpt_root':args.ckpt_root_JHH,
        #                 'group_root':args.group_root_JHH,
        #                 'subplot':fig.add_subplot(gs[i, 3]),
        #                 'test_set_only':False,
        #                 'organ':organDict[organ]})



    for config in configs:
        p_args = Namespace()
        p_args.ckpt_root=config['ckpt_root']
        p_args.group_root=config['group_root']
        p_args.nsd=args.nsd
        p_args.organ=config['organ']
        p_args.mean_and_best=False
        p_args.test_set_only=config['test_set_only']
        p_args.title=config['title']
        p_args.split_path=args.split_path
        StatisticalHeatmap.HeatmapOfSignificance(p_args,ax=config['subplot'])



        #configs.subplot.set_title(f'Plot {i + 1}')
        #configs.subplot.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')

    plt.tight_layout()
    os.makedirs('../outputs/heatmaps',exist_ok=True)
    filename='../outputs/heatmaps/significance_heatmaps_'+args.organs.replace(' ','_')
    if args.nsd:
        filename+='_nsd'
    filename+='.pdf'
    plt.savefig(filename,bbox_inches='tight', pad_inches=0)
    plt.close()

if __name__ == "__main__":
    args = parse_arguments()
    if args.organs=='first_half':
        args.organs='spleen kidneyR kidneyL gallbladder liver'
    if args.organs=='second_half':
        args.organs='stomach aorta IVC pancreas'# average'
    create_multiple_boxplots(args)


# PlotGroup.py

import argparse
import pandas as pd
import os
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import scipy.stats as stats
from statannotations.Annotator import Annotator
from itertools import combinations

def parse_arguments():
    parser = argparse.ArgumentParser(description='Generate dot and boxplots with confidence intervals.')
    parser.add_argument('--ckpt_root', type=str, help='Path to the directory containing model result CSV files')
    parser.add_argument('--group_root', type=str, help='Path to the directory containing group sample lists')
    parser.add_argument('--group_name', type=str, help='Group name to filter the sample lists')
    parser.add_argument('--nsd', action='store_true', help='Plot dice if not set', default=False)
    parser.add_argument('--organ', help='Organ to plot, or mean', default='mean')
    parser.add_argument('--split_path', default='../utils/metaTotalSeg.csv', help='Location of TotalSegmentator metadata')
    parser.add_argument('--test_set_only', action='store_true', help='Tests only on totalSegmentator test set', default=False)
    parser.add_argument('--mean_and_best', action='store_true', help='Plot only results for nnU-Net and for average of all models', default=False)
    parser.add_argument('--just_mean', action='store_true', help='Plot only results for average of all models', default=False)
    parser.add_argument('--th', help='exclude groups with less samples than th',default=5)
    parser.add_argument('--orientation', help='Plot orientation, h or v or auto',default='auto')
    parser.add_argument('--stats', action='store_true', help='Plot only results for nnU-Net and for average of all models', default=False)
    parser.add_argument('--font', default=11)
    parser.add_argument('--fig_length', default='10')



    return parser.parse_args()

#gives model order in plot
model_ranking=['Average AI Algorithm','STU-Net','nnU-Net U-Net',
               'nnU-Net ResEncL','MedNeXt','UniSeg','Diff-UNet','LHU-Net','U-Net & CLIP',
               'NexToU','SegResNet','SwinUNETR & CLIP','SegVol',
               'UCTransNet','UNEST','SwinUNETR','UNETR','SAM-Adapter','CleanNet']

#palette = sns.color_palette('bright', 30)
cmap = plt.get_cmap('tab20')
palette = [cmap(i % 20) for i in range(len(model_ranking))]
model_color_dict = dict(zip(model_ranking, palette))
#print(model_color_dict)

def find_color(model):
    for i,m in enumerate(model_ranking,0):
        if m in model:
            return palette[i]
    raise ValueError('Uncrecognized model: '+model)

def Kruskal_Wallis(df):

    groups=df['Group'].unique()

    grouped_data = df.groupby('Group')['Value'].apply(list)


    ## Prepare the data for the Kruskal-Wallis test
    values = [group for group in grouped_data]
    h_statistic, p_value = stats.kruskal(*values)

    if p_value>0.05:
        return None #no significant result


    #Post-hoc tests: Wilcoxon rank sum tests/Mann–Whitney U test
    results = []

    # Perform pairwise Wilcoxon rank sum tests
    for (group1, group2) in combinations(groups, 2):
        group1_values = df[df['Group'] == group1]['Value']
        group2_values = df[df['Group'] == group2]['Value']
        stat, p_value = stats.mannwhitneyu(group1_values, group2_values, alternative='two-sided')
        results.append((group1, group2, p_value))

    # Convert results to a DataFrame
    results_df = pd.DataFrame(results, columns=['Group1', 'Group2', 'P-Value'])

    # Apply FDR correction using Benjamini-Hochberg method
    pvals_corrected = stats.false_discovery_control(results_df['P-Value'], method='bh')
    results_df.loc[:, 'P-Value Adjusted'] = pvals_corrected

    significant_results = results_df[results_df['P-Value Adjusted'] < 0.05]
    return significant_results


def Kruskal_Wallis_Pure(df):

    groups=df['Group'].unique()

    grouped_data = df.groupby('Group')['Value'].apply(list)


    ## Prepare the data for the Kruskal-Wallis test
    values = [group for group in grouped_data]
    h_statistic, p_value = stats.kruskal(*values)

    if p_value<0.05:
        return True
    else:
        return False


def rename_model(string):
    if 'yiwen' in string or 'uniseg' in string or 'UniSeg' in string:
        return 'UniSeg'
    elif 'zhaohu' in string or 'Diff-UNet' in string:
        return 'Diff-UNet'
    elif 'UCTransNet' in string or 'uctransnet' in string:
        return 'UCTransNet'
    elif 'SegVol' in string or 'BoZhao' in string:
        return 'SegVol'
    elif 'Saikat' in string or 'mednext' in string or 'MedNeXt' in string:
        return 'MedNeXt'
    elif 'SegResNet' in string or 'SuPreM_segresnet' in string:
        return 'SegResNet'
    elif 'nextou' in string or 'NexToU' in string:
        return 'NexToU'
    elif 'SuPreM_UNet' in string or 'SuPreM_unet' in string or 'U-Net_CLIP' in string or 'U-Net and CLIP' in string:
        return 'U-Net & CLIP'
    elif 'SuPreM_swinunetr' in string or 'Swin_UNETR_CLIP' in string or 'Swin UNETR and CLIP' in string:
        return 'SwinUNETR & CLIP'
    elif 'LHUNet' in string or 'LHU-Net' in string:
        return 'LHU-Net'
    elif 'ResEncL' in string or ('riginal' not in string and ('nnUNet' in string or 'nnunet' in string)):
        return 'nnU-Net ResEncL'
    elif 'nnU-Net_U-Net' in string or 'nnU-Net U-Net' in string or ('riginal' in string and ('nnUNet' in string or 'nnunet' in string)):
        return 'nnU-Net U-Net'
    elif ('swinunetr' in string or 'Swin_UNETR' in string or 'Swin UNETR' in string) and 'SuPreM' not in string and 'CLIP' not in string:
        return 'SwinUNETR'
    elif 'STU_base' in string or 'STUNetBase' in string or 'STU-Net-B' in string or 'STU-Net' in string:
        return 'STU-Net'
    elif 'SAM' in string:
        return 'SAM-Adapter'
    elif ('unetr' in string or 'UNETR' in string) and 'SuPreM' not in string and 'CLIP' not in string:
        return 'UNETR'
    elif ('UNEST' in string or 'unest' in string or 'UNesT' in string) and 'SuPreM' not in string and 'CLIP' not in string:
        return 'UNEST'
    elif 'CleanNet' in string:
        return 'CleanNet'
    else:
        return string

def rename_group(string,args):
    if args.group_name=='ages':
        return string[string.rfind('ages'):string.rfind('ages')+10].replace('_',' ')
    elif args.group_name=='diagnosis':
        return string[string.rfind('diagnosis_')+len('diagnosis_'):\
                      string.rfind('_')].replace('_',' ')
    elif args.group_name=='cancer_diagnosis':
        return string[string.find('cancer_diagnosis_')+len('cancer_diagnosis_'):\
                      string.rfind('_')].replace('_',' ')
    elif args.group_name=='sex':
        return string[string.rfind('sex_')+len('sex_'):\
                      string.rfind('_')].replace('_',' ')
    elif args.group_name=='race':
        return string[string.rfind('race_')+len('sex_'):].replace('_',' ')
    elif args.group_name=='institute':
        return string[string.rfind('institute_'):string.rfind('_')].replace('_',' ')
    elif args.group_name=='manufacturer':
        if 'ge' in string:
            return 'GE'
        elif 'siemens' in string:
            return 'Siemens'
        elif 'philips' in string:
            return 'Philips'
        else:
            return string[string.rfind('manufacturer_')+len('manufacturer_'):\
                          string.rfind('_')].replace('_',' ')
    elif args.group_name=='all':
        return ''
    elif args.group_name=='scanner_model':
        return string[string.rfind('scanner_model_')+len('scanner_model_'):string.rfind('_')].replace('_',' ')
    else:
        return string

def intersect(list1,list2):
    # Convert lists to sets
    set1 = set(list1)
    set2 = set(list2)
    # Find the intersection of both sets
    intersection = set1.intersection(set2)
    # Count the number of elements in the intersection
    return len(intersection)

def mean_model_performance(df_dict,groups_lists=None,args=None):
    #df_dict: results per model
    combined_df = pd.concat(df_dict.values(), axis=0)
    # Group by 'names' and compute the mean across all original DataFrames
    df = combined_df.groupby('name').mean().reset_index()

    if groups_lists is not None:#not for all and ages
        long_df = convert_to_long_format(df, model_name='avg',args=args)
        long_df = long_df.dropna(subset=['Value'])  # Drop rows with NaN values in 'Value'
        means={}
        for group_name, sample_list in groups_lists.items():
            group_df = long_df[long_df['name'].isin(sample_list)]
            means[group_name]=group_df['Value'].mean()
        group_order=sorted(means, key=lambda k: means[k], reverse=True)
        return group_order
    else:
        return df

def order_models(models):
    tmp=[]
    for model in model_ranking:
        if model in models:
            tmp.append(model)

    for model in models:
        if model not in model_ranking:
            raise ValueError('Unranked model: ', model, ', please add it to model_ranking list inside this code, in the correct position, according to the overall raking')

    return tmp



def read_models_and_groups(args):
    #th: exclude groups with less samples than th
    th=int(args.th)


    # Load model results
    #remove yiwen from dap atlas
    if not args.nsd:
        model_files = [os.path.join(file,'dsc.csv') for file in os.listdir(args.ckpt_root)]
    else:
        model_files = [os.path.join(file,'nsd.csv') for file in os.listdir(args.ckpt_root)]

    model_names = [rename_model(file[:file.rfind('/')]) for file in model_files]

    if args.test_set_only:
        split=pd.read_csv(args.split_path,sep=';')
        test_image_ids = split.loc[split['split'] == 'test', 'image_id'].tolist()
        results = {model: pd.read_csv(os.path.join(args.ckpt_root,file))\
                   [pd.read_csv(os.path.join(args.ckpt_root,file))['name'].isin(test_image_ids)]\
                   for model, file in zip(model_names, model_files)}
    else:
        results = {model: pd.read_csv(os.path.join(args.ckpt_root,file))\
                   for model, file in zip(model_names, model_files) if '.DS_Store' not in model}

    if args.mean_and_best:
        results={'Average AI Algorithm':mean_model_performance(results),
                 'nnU-Net':results['nnU-Net']}
        model_names = ['Average AI Algorithm','nnU-Net']
    if args.just_mean:
        results={'Average AI Algorithm':mean_model_performance(results)}
        model_names = ['Average AI Algorithm']

    samples=results[list(results.keys())[0]]['name'].to_list()


    no_nan_samples=convert_to_long_format(results[list(results.keys())[0]],
                                          model_name=list(results.keys())[0],
                                          args=args).dropna(subset=['Value'])['name'].to_list()

    if args.group_name=='all':#1 group with all samples
        groups_lists={'all':samples}
        print('Samples: ',len(groups_lists['all']))
    else:#per group-analysis
        # Load group lists
        group_files = [file for file in os.listdir(args.group_root) if '.pt' in file and args.group_name in file]
        groups_lists = {rename_group(os.path.splitext(file)[0],args): torch.load(os.path.join(args.group_root, file)) for file in group_files \
   if intersect(torch.load(os.path.join(args.group_root, file)),no_nan_samples)>=th}

    order=[]
    group_names=list(groups_lists.keys())
    model_names=order_models(model_names)
    if args.group_name!='all' and args.group_name!='ages':
        #sort groups by average model performance
        group_names=mean_model_performance(results,groups_lists,args)
    else:
        group_names=sorted(group_names)


    for model_name in model_names:
        for group_name in group_names:
            if args.group_name!='all':
                order.append(f"{model_name}-{group_name}")
            else:
                order.append(model_name)


    num_groups=len(group_names)
    num_algos=len(model_names)
    #print(group_names)

    return results, groups_lists, order, num_groups, num_algos

def convert_to_long_format(df, model_name,args):
    if args.organ=='mean':#data points are per-ct mean scores
        df['Average'] = df.iloc[:, 1:].mean(axis=1)
        # Create a new DataFrame with just the 'Name' and 'Average' columns
        df = df[['name', 'Average']]
    elif args.organ=='all':#data points are all per-organ values (points~number of organs x number of cts)
        pass
    else:#per-organ plot
        df = df[['name', args.organ]]



    # Melt the DataFrame from wide to long format
    long_df = df.melt(id_vars=['name'], var_name='Organ', value_name='Value')
    long_df['Model'] = model_name
    return long_df

def create_long_format_dataframe(results, groups_lists,args):
    data = []


    for model_name, df in results.items():
        long_df = convert_to_long_format(df, model_name,args)
        long_df = long_df.dropna(subset=['Value'])  # Drop rows with NaN values in 'Value'

        for group_name, sample_list in groups_lists.items():
            if args.group_name!='all':
                combined_group_name = f"{model_name}-{group_name}"
            else:
                combined_group_name = model_name
            group_df = long_df[long_df['name'].isin(sample_list)].copy()
            group_df['Group'] = combined_group_name#modified latter, was group_df['Group'] =
            data.append(group_df[['Group', 'Value']])

    # Concatenate all DataFrames into a single DataFrame
    final_df = pd.concat(data)

    return final_df


def break_title(title,fig_width):
    # Adjust max_char_in_line based on figure width
    char_per_inch = 8  # Approximate number of characters per inch
    max_char_in_line = int((fig_width * char_per_inch)//1)

    # Break title into multiple lines if necessary
    parts = []
    while len(title) > max_char_in_line:
        part = title[:max_char_in_line]
        next_space = part.rfind(' ')
        if next_space != -1:
            parts.append(part[:next_space])
            title = title[next_space+1:]
        else:
            parts.append(part)
            title = title[max_char_in_line:]
    parts.append(title)
    title = '\n'.join(parts)
    return title


def second_last_rfind(s, char):
    # Find the last occurrence of the character
    last_occurrence = s.rfind(char)
    if last_occurrence == -1:
        return -1  # Character not found at all
    # Find the second last occurrence by slicing the string up to the last occurrence
    second_last_occurrence = s.rfind(char, 0, last_occurrence)
    return second_last_occurrence

def remove_model(value):

    if 'Average AI Algorithm' in value:
        return value.replace('Average AI Algorithm','Avg.')
    # Example transformation: append '_modified' to each group name
    return value

def find_model(value):
    for m in model_ranking+['Avg.','Average AI Algorithm']:
        if m in value:
            return m

organDict={ 'spleen':'spleen',
            'kidney_right':'kidneyR',
            'kidney_left':'kidneyL',
            'gall_bladder':'gallbladder',
            'liver':'liver',
            'stomach':'stomach',
            'aorta':'aorta',
            'postcava':'IVC',
            'pancreas':'pancreas',
            'mean':'average'}

def create_boxplot(long_df, group_order, num_groups, args, num_algos, ax=None,save=False,
                   hide_model=False,limits=None,omit_metric=False,significance_test=True,
                   colorful=True,title_style=None,rotation=45,font=13,fig_length=10):

    if 'totalsegmentator_results' in args.ckpt_root:
        dataset='TotalSegmentator'
    elif 'dapatlas_results' in args.ckpt_root:
        dataset='DAP Atlas'
    elif 'PrivateGT' in args.ckpt_root or 'privateGT' in args.ckpt_root or 'JHH' in args.ckpt_root:
        dataset='JHH'
    else:
        dataset=''

    #this one rotates, the old one does not
    fig_width=len(group_order)*num_algos/36

    # Determine the plot orientation based on the number of groups
    if args.orientation=='h' or (args.orientation=='auto' and fig_width<10):  # You can adjust this threshold
    #if args.group_name=='all':
        if num_algos<=2:
            fig_width=fig_width*36/9
        fig_width=max(fig_width,2)
        orientation = 'h'
        figsize = (fig_length, fig_width)  # Height based on number of groups
        xlabel = 'Value'
        ylabel = 'Group'
        w=10*0.9
        r=0
    elif args.orientation=='v' or (args.orientation=='auto' and fig_width>=10):
        fig_width=max(fig_width,3)
        orientation = 'v'
        figsize = (fig_width, fig_length)  # Width based on number of groups
        xlabel = 'Group'
        ylabel = 'Value'
        w=fig_width*0.9
        r=rotation
    else:
        raise ValueError('Unrecognized args.orientation, use h, v or auto')

    #reorder
    category_type = pd.CategoricalDtype(categories=group_order, ordered=True)
    long_df['Group'] = long_df['Group'].astype(category_type)
    long_df.sort_values('Group', inplace=True)

    if hide_model:
        long_df['Group'] = long_df['Group'].apply(remove_model)


    if args.group_name!='all':
        color_palette=[find_color(i) for i in group_order]
    else:
        color_palette=[model_color_dict[i] for i in group_order]

    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)
    else:
        plt.sca(ax)

    if not colorful:
        color_dict = {
        "TotalSegmentator": ["#FFA500"],  # Orange
        "DAP Atlas": ["#0000FF"],  # Blue
        "JHH": ["#008000"]   # Green
        }
        for key in color_dict:
            if key in dataset:
                color_palette=color_dict[key]

    ax=sns.boxplot(
        x=xlabel,
        y=ylabel,
        data=long_df,
        palette=color_palette,
        #order=group_order if orientation == 'v' else None,
        order=None,#reordered above
        fliersize=1,
        width=0.7,
        orient=orientation,
        ax=ax
    )

    metric = 'NSD' if args.nsd else 'dice score'

    organ = args.organ.replace('_', ' ')
    title = f'{organ} {metric}'
    group_name = 'cancer diagnosis' if args.group_name == 'cancer_diagnosis' else args.group_name

    if orientation == 'v':
        if not hide_model:
            if group_name != 'all':
                plt.xlabel('AI Algorithm-Group',fontsize=font)
            else:
                plt.xlabel('AI Algorithm',fontsize=font)
        else:
             plt.xlabel('')
        if not omit_metric:
            plt.ylabel(metric,fontsize=font)
        else:
            plt.ylabel('')

    else:
        if not hide_model:
            if group_name != 'all':
                plt.ylabel('AI Algorithm-Group',fontsize=font)
            else:
                plt.ylabel('AI Algorithm',fontsize=font)
        else:
             plt.ylabel('')
        if not omit_metric:
            plt.xlabel(metric,fontsize=font)
        else:
            plt.xlabel('')
            print('no METRIC')



    if group_name != 'all':
        title += ' by ' + group_name



    title += ' in ' + dataset
    if args.test_set_only:
        title += ' official test set'

    if title_style=='group':
        title=group_name

    if title_style=='organ_dataset':
        title=organDict[args.organ]+' - '+dataset

    if title_style=='organ':
        title=organDict[args.organ]

    title=title.replace('PrivateGT','JHH')
    title=title.replace('DAPAtlas','DAP Atlas')


    try:
        plt.title(break_title(title,fig_width=w), fontsize=max(19,font))
    except:
        plt.title(break_title(title,fig_width=w), fontsize=max(19,font))


    plt.xticks(rotation=r, ha='right', fontsize=font)
    plt.tight_layout()

    if orientation=='h' and hide_model:
         plt.yticks(rotation=45, ha='right', fontsize=font)

    if orientation=='v':
        # Set more divisions on the y-axis
        plt.yticks(np.arange(0, 1.1, 0.1))
        plt.tight_layout()
        if limits is not None:
            ax.set_ylim(limits[0], limits[1])
        else:
            # Adjust y-axis limits to remove the bottom empty space
            y_min = long_df['Value'].min()
            buffer = (long_df['Value'].max() - y_min) * 0.05  # Create a buffer of 10% of the range
            y_min=max(y_min - buffer,0)
            ax.set_ylim(y_min, 1.0)  # Assuming your data values range between 0 and 1
        plt.xticks(fontsize=font)
    if orientation=='h':
        # Set more divisions on the y-axis
        plt.xticks(np.arange(0, 1.1, 0.2), fontsize=font)
        plt.tight_layout()
        if limits is not None:
            ax.set_xlim(limits[0], limits[1])
        else:
            # Adjust y-axis limits to remove the bottom empty space
            x_min = long_df['Value'].min()
            buffer = (long_df['Value'].max() - x_min) * 0.05  # Create a buffer of 10% of the range
            x_min=max(x_min - buffer,0)
            ax.set_xlim(x_min, 1.0)  # Assuming your data values range between 0 and 1
        plt.yticks(fontsize=font)

    if significance_test:
        if Kruskal_Wallis_Pure(long_df) and args.group_name!='all':
            group_comb=[item for item in combinations(long_df['Group'].unique(), 2)]
            group_comb=[item for item in group_comb if find_model(item[0])==find_model(item[1])]

            #print(group_comb)

            annotator = Annotator(ax, group_comb, x=xlabel,
            y=ylabel,
            data=long_df,
            order=None,#reordered above
            orient=orientation)
            annotator.configure(test='Mann-Whitney', text_format='star', loc='inside',
                               comparisons_correction='Bonferroni',hide_non_significant=True,
                               text_offset=0, line_height=0.01, fontsize=13)
            annotator.apply_and_annotate()

    if args.just_mean:
        # Modify individual ytick labels to remove 'Avg.-'
        new_labels = [label.get_text().replace('Avg.-', '') for label in ax.get_yticklabels()]

        # Set the new y-tick labels
        ax.set_yticklabels(new_labels, rotation=0, ha='right')
    if hide_model:
        new_labels = ['' for label in ax.get_yticklabels()]

        # Set the new y-tick labels
        if orientation=='v':
            ax.set_xticklabels(new_labels, rotation=0, ha='right')
        if orientation=='h':
            ax.set_yticklabels(new_labels, rotation=0, ha='right')


    folder = '../outputs/box_plots/box_plots_' + dataset
    if args.test_set_only:
        folder += '_test_set'
    os.makedirs(folder, exist_ok=True)
    if args.mean_and_best:
        title+=' mean and NNU-Net'
    if args.just_mean:
        title+=' mean'
    if save:
        title='Boxplot of '+title
        plt.savefig(folder + '/' + title.replace('/', ' ').replace('\n', ' ') + '.pdf', dpi=300,
                   bbox_inches='tight')
        plt.show()


if __name__ == "__main__":
    args = parse_arguments()

    results, groups_lists, order, num_groups, num_algos = read_models_and_groups(args)
    print('Read models and groups')

    long_df = create_long_format_dataframe(results, groups_lists, args)
    print('Created long format DataFrame')



    # Optionally, save the DataFrame to a CSV file
    long_df.to_csv("combined_long_format.csv", index=False)
    print('Saved long format DataFrame to combined_long_format.csv')

    create_boxplot(long_df, group_order=order, num_groups=num_groups,args=args,
                   num_algos=num_algos,significance_test=args.stats,
                   font=int(args.font),fig_length=int(args.fig_length),save=True)



# SignificanceMaps.py


import PlotGroup as pg
from argparse import Namespace
from PlotGroup import read_models_and_groups, create_long_format_dataframe
import argparse
import scipy.stats as stats
from itertools import combinations
import numpy as np
import pandas as pd
import warnings
from scipy.stats import wilcoxon
from statsmodels.stats.multitest import multipletests
import seaborn as sns
import matplotlib.pyplot as plt

# Function to perform one-sided Wilcoxon signed-rank test
def wilcoxon_one_sided(x, y):
    try:
        res = wilcoxon(x,y, alternative='greater',nan_policy='raise')
    except ValueError as e:
        if str(e) == "zero_method 'wilcox' and 'pratt' do not work if x - y is zero for all elements.":
            return np.array([100.0])
        else:
            # Re-raise the exception if it doesn't match
            raise
    return res.pvalue

# Suppress specific warning
warnings.filterwarnings("ignore", category=UserWarning)

def parse_arguments():
    parser = argparse.ArgumentParser(description='Statistical tests')
    parser.add_argument('--organ', type=str, help='model name',default='mean')
    parser.add_argument('--title', type=str, help='title',default='')
    parser.add_argument('--ckpt_root', type=str, help='Path to the directory containing model result CSV files',default='/run/media/pedro/e911bf59-fe8e-4ddb-8938-5dc4f40b094f/Checkpoints/Metrics/TotalSegmentator/')
    parser.add_argument('--nsd', action='store_true', help='Plot dice if not set', default=False)
    parser.add_argument('--test_set_only', action='store_true', help='Plot dice if not set', default=False)
    parser.add_argument('--split_path', default='/run/media/pedro/e911bf59-fe8e-4ddb-8938-5dc4f40b094f/metaTotalSeg.csv', help='Location of TotalSegmentator metadata')
    return parser.parse_args()


def rank(results,args):
    #changes begin here
    means={}
    for model in results:
        if args.organ=='mean':
            #means[model]=results[model]['Average'].mean()
            try:
                means[model]=results[model].drop(
                    columns=['Average']).mean(numeric_only=True,axis=1).median()
            except:
                means[model]=results[model].mean(numeric_only=True,axis=1).median()
        else:
            means[model]=results[model][args.organ].median()
    sorted_keys_descending = sorted(means, key=means.get, reverse=True)
    #print(means)
    #changes end here

    return sorted_keys_descending

def allign(df1,df2):
    #print(df1,df2)
    #Step 1: Remove rows with NaN values
    df1_clean = df1.dropna().reset_index(drop=True).drop_duplicates(subset=['name'])
    df2_clean = df2.dropna().reset_index(drop=True).drop_duplicates(subset=['name'])
    #print(df1_clean)

    # Step 2: Find the intersection of 'name' values
    common_names = set(df1_clean['name']).intersection(set(df2_clean['name']))

    # Step 3: Subset both DataFrames to only include rows with these common 'name' values
    df1_subset = df1_clean[df1_clean['name'].isin(common_names)].reset_index(drop=True)
    df2_subset = df2_clean[df2_clean['name'].isin(common_names)].reset_index(drop=True)

    # Step 4: Ensure that both DataFrames have the same order of rows by sorting
    df1_subset = df1_subset.sort_values(by='name').reset_index(drop=True)
    df2_subset = df2_subset.sort_values(by='name').reset_index(drop=True)

    # Verify that both DataFrames have the same order of 'name' values
    #print(df1_subset['name'],df2_subset['name'])
    assert (df1_subset['name']==df2_subset['name']).all()
    #print(df1_subset['name'],df2_subset['name'])
    df1_subset,df2_subset=df1_subset.drop(columns=['name']),df2_subset.drop(columns=['name'])
    #print(df1_subset,df2_subset)
    return df1_subset,df2_subset

def HeatmapOfSignificance(args,ax=None):
    flag=(ax is None)

    #Use for only per-group comparisons
    p_args = Namespace()
    p_args.group_name='all'
    p_args.ckpt_root=args.ckpt_root
    #p_args.group_root=args.group_root
    p_args.nsd=args.nsd
    p_args.organ=args.organ
    p_args.th=10
    p_args.test_set_only=args.test_set_only
    p_args.mean_and_best=False
    p_args.just_mean=False
    p_args.split_path=args.split_path
    results, groups_lists, order, num_groups, num_algos = read_models_and_groups(p_args)
    groups=rank(results,args)
    for model in results:#get only organ we want
        if args.organ=='mean':
            #try:
            #    results[model]['mean']=results[model].drop(columns=['Average','name']).mean(axis=1)
            #except:
            #    results[model]['mean']=results[model].drop(columns=['name']).mean(axis=1)
            #results[model]=results[model][['name', 'mean']]
            try:
                results[model]=results[model][['name', 'Average']]
            except:
                #print('Problem: no Average in ',model)
                #print(results[model])
                results[model]['Average']=results[model].drop(columns=['name']).mean(axis=1)
                #print(results[model].drop(columns=['name']).mean(axis=1))
                results[model]=results[model][['name', 'Average']]
                #print(results[model])
        else:
            results[model]=results[model][['name', args.organ]]


    comparisons = list(combinations(groups, 2))

    # Perform pair-wise tests
    p_values = []
    tmp=[]
    for (group1, group2) in comparisons:
        #print(group1,group2)
        df1, df2=allign(results[group1], results[group2])
        p1 = wilcoxon_one_sided(df1, df2)
        p_values.append(p1.item())
        tmp.append((group1, group2))
        p2 = wilcoxon_one_sided(df2, df1)
        p_values.append(p2.item())
        tmp.append((group2, group1))
    comparisons=tmp

    #print(p_values)

    for i,p in enumerate(p_values,0):
        group1, group2=comparisons[i]
        #print(group1,'>', group2,'p:',p)

    # Correct for multiple comparisons using Holm's method
    _, corrected_p_values, _, _ = multipletests(p_values, method='holm')
    #print(len(p_values),len(corrected_p_values))
    #corrected_p_values=p_values

    for i,p in enumerate(corrected_p_values,0):
        group1, group2=comparisons[i]
        #print(group1,'>', group2,'p:',p)


    # Create a DataFrame to store the results
    significance_matrix = pd.DataFrame(np.nan, index=list(reversed(groups)), columns=groups)


    # Fill in the matrix with corrected p-values
    for (group1, group2), p in zip(comparisons, corrected_p_values):
        if p < 0.05:
            significance_matrix.loc[group2, group1] = 1  # Yellow
            #significance_matrix.loc[group1, group2] = -1  # Blue
        else:
            #significance_matrix.loc[group1, group2] = -1
            significance_matrix.loc[group2, group1] = -1

    # Create a custom color map
    from matplotlib.colors import ListedColormap

    cmap = ListedColormap(['blue', 'white', 'yellow'])

    # Revert the order of the y-axis labels
    #reversed_groups = groups[::-1]

    # Plotting the significance map using a heatmap
    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 4))
    else:
        plt.sca(ax)

    ax = sns.heatmap(significance_matrix, annot=False, cmap=cmap, center=0,
                     xticklabels=groups, yticklabels=list(reversed(groups)), linewidths=0.5, linecolor='gray',
                     cbar=False,ax=ax)

    # Diagonal line to separate significant and non-significant areas
    plt.plot([0, len(groups)], [len(groups), 0], color='black', lw=1)

    plt.title(args.title)
    #plt.xlabel('Algorithm')
    #plt.ylabel('Algorithm')
    # Rotate x-axis labels by 45 degrees
    #ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha='right')
    #ax.set_yticklabels(ax.get_yticklabels(), rotation=0, ha='right')


    if flag:
        plt.show()

def HeatmapOfSignificanceNoCorrection(args,ax=None):
    flag=(ax is None)

    #Use for only per-group comparisons
    p_args = Namespace()
    p_args.group_name='all'
    p_args.ckpt_root=args.ckpt_root
    #p_args.group_root=args.group_root
    p_args.nsd=args.nsd
    p_args.organ=args.organ
    p_args.th=10
    p_args.test_set_only=args.test_set_only
    p_args.mean_and_best=False
    p_args.just_mean=False
    p_args.split_path=args.split_path
    results, groups_lists, order, num_groups, num_algos = read_models_and_groups(p_args)
    groups=rank(results,args)
    for model in results:#get only organ we want
        if args.organ=='mean':
            try:
                results[model]['mean']=results[model].drop(columns=['Average','name']).mean(axis=1)
            except:
                results[model]['mean']=results[model].drop(columns=['name']).mean(axis=1)
            results[model]=results[model][['name', 'mean']]
        else:
            results[model]=results[model][['name', args.organ]]


    comparisons = list(combinations(groups, 2))

   # Perform pair-wise tests
    p_values = []
    tmp=[]
    for (group1, group2) in comparisons:
        df1, df2=allign(results[group1], results[group2])
        p1 = wilcoxon_one_sided(df1, df2)
        p_values.append(p1.item())
        tmp.append((group1, group2))
        p2 = wilcoxon_one_sided(df2, df1)
        p_values.append(p2.item())
        tmp.append((group2, group1))
    comparisons=tmp

    #print(p_values)

    for i,p in enumerate(p_values,0):
        group1, group2=comparisons[i]
        print(group1,'>', group2,'p:',p)

    # Correct for multiple comparisons using Holm's method
    #p_crr={}
    #for model in groups:
    #    pc=[[comp,p_values[i]] for i,comp in enumerate(comparisons,0) if comp[0]==model]
    #    p=[pval for comp,pval in pc]
    #    _, corrected_p_values, _, _ = multipletests(p, method='holm')
    #
    #    for i,comp in enumerate(comparisons,0):
    #        for j,(comp2,_) in enumerate(pc,0):
    #            if comp2==comp:
    #                p_values[i]=corrected_p_values[j]
    #
    #    corrected_p_values=p_values

    corrected_p_values=p_values
    # Create a DataFrame to store the results
    significance_matrix = pd.DataFrame(np.nan, index=list(reversed(groups)), columns=groups)


    # Fill in the matrix with corrected p-values
    for (group1, group2), p in zip(comparisons, corrected_p_values):
        if p < 0.05:
            significance_matrix.loc[group2, group1] = 1  # Yellow
            #significance_matrix.loc[group1, group2] = -1  # Blue
        else:
            #significance_matrix.loc[group1, group2] = -1
            significance_matrix.loc[group2, group1] = -1

    # Create a custom color map
    from matplotlib.colors import ListedColormap

    cmap = ListedColormap(['blue', 'white', 'yellow'])

    # Revert the order of the y-axis labels
    #reversed_groups = groups[::-1]

    # Plotting the significance map using a heatmap
    if ax is None:
        fig, ax = plt.subplots(figsize=(5, 4))
    else:
        plt.sca(ax)

    ax = sns.heatmap(significance_matrix, annot=False, cmap=cmap, center=0,
                     xticklabels=groups, yticklabels=list(reversed(groups)), linewidths=0.5, linecolor='gray',
                     cbar=False,ax=ax)

    # Diagonal line to separate significant and non-significant areas
    plt.plot([0, len(groups)], [len(groups), 0], color='black', lw=1)

    plt.title(args.title)
    #plt.xlabel('Algorithm')
    #plt.ylabel('Algorithm')
    # Rotate x-axis labels by 45 degrees
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha='right')


    if flag:
        plt.show()

if __name__ == "__main__":
    args = parse_arguments()
    HeatmapOfSignificance(args)